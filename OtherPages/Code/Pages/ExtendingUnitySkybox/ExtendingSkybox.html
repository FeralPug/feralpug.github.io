<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Feral_Pug Codes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../../../../StyleSheets/EveryPage/stylesGeneral.css" />
    <link rel="stylesheet" href="../../../../StyleSheets/BlogStyles/stylesBlogPost.css" />
    <link rel="stylesheet" href="../../../../Prism/prism.css" />
    <script src="../../../../Scripts/markFixer.js" defer></script>
    <script src="../../../../Scripts/ScriptLoader.js" defer></script>

</head>
<body>
    <header>
        <div class="Banner" id="Top">Feral_Pug Codes</div>
    </header>

    <div class="SocialNav">
        <ul>
            <li>
                <a href="https://ko-fi.com/feral_pug" title="Link to my Ko-fi page" target="_blank">
                    <img src="../../../../Media/Icons/Ko-fiLogo.png" alt="Ko-Fi Logo" width="32" />
                </a>
            </li>
            <li>
                <a href="https://twitter.com/Feral_Pug" title="Link to my twitter page" target="_blank">
                    <img src="../../../../Media/Icons/twitterLogo.svg" alt="Twitter Logo" width="32" />
                </a>
            </li>
        </ul>
    </div>

    <div class="NavContainer">
        <nav>
            <ul>
                <li>
                    <a href="../../../../index.html">Home</a>
                </li>
                <li>
                    <a href="../../../GamesPage/Games.html">Games</a>
                </li>
                <li>
                    <a href="../../../Code/Code.html">Code Blog</a>
                </li>
                <li>
                    <a href="../../../Tools/Tools.html">Tools</a>
                </li>
                <li>
                    <a href="../../../Support/Support.html">Support</a>
                </li>
            </ul>
        </nav>
    </div>

    <main>
        <article>
            <h1 class="Section" id="PostStart">
                Extending The Unity Procedural Skybox
            </h1>

            
            <p class="PageText">
                Skyboxes can be a great way to add a sense of place to a game, and a
                procedural one can be a great way to create lots of different environments by just
                adjusting some material properties. However, they can be a little complicated to
                get right.
            </p>

            <p class="PageText">
                I have messed around with a lot of different techniques for making procedural
                skyboxes but I think I have landed on what is my favorite of all the versions
                I have made. In this post I will show you how to create a great skybox
                that has a lot of cool customizable features, like the one below.
            </p>
            

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/ExtendingSkyboxCapture.png" alt="Image of the final Result" />
                <p class="PageImageText"> An example of what you can do with procedural skyboxes and what our final shader will look like.</p>
            </div>

            <h2 class="Section" id="Part1">Part 1: Background on Skies</h2>

            <p class="PageText">
                Skies in the real world have a lot of aspects to them that we can think of and try to replicate. For example, the color of the sky, the
                desaturation of that color as you look to the horizon, sunsets. It is not too difficult to come up with some math and slap it into a shader
                to replicate these aspects of a sky. However, in my experience they often work best when you know exactly what you want and can work backwards to
                figure out how you can fake that inside of a shader. Which in a lot of cases is fine but I think we can do better, and a lot of people have.
            </p>

            <p class="PageText">
                The way skies look is due to what is known as <a href="https://en.wikipedia.org/wiki/Rayleigh_scattering" title="Wiki page for light scattering" target="_blank">light scattering</a>.
                As light passes through the atmosphere it gets redirected in all sorts of directions
                by small particles floating in the air. This refracts different wave lengths of light in different directions and is why the sky is blue, blue light gets
                refracted towards your eye while other colors are refracted away from your eye. And as it turns out the math behind how this work is incredibly complicated.
                For real time graphics, trying to implement this exactly is practically impossible. However, if we can approximate it, we can get the result we want at an acceptable
                computational cost. As it turns out people have been working on this for a while and the folks at NVIDIA have come up with a great method you can read about
                <a href="https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering" title="Link to NVIDIA page about this topic" target="_blank">here</a>,
                which I recommend reading.
            </p>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/LightScatteringExample.png" alt="Picture of procedural light scattering" />
                <p class="PageImageText">
                    With good light scattering you can simulate awesome aspects of the sky
                    like a sunset.
                </p>
            </div>

            <p class="PageText">
                Anyway, there is no reason to reinvent the wheel here. The work has already been done to approximate this effect and Unity has a shader that uses this approximation
                to create a realistic looking sky like the one you can see above. I am not going to explain how this works, if you read the NVIDIA article and compare it to Unity&rsquo;s
                shader you will be able to connect the dots. What we are going to do is extend this shader to add cool things like clouds, stars, and a textured moon object.
            </p>

            <h2 class="Section" id="Part2">Part 2: The Setup</h2>

            <p class="PageText">
                So, to get started head over to the <a href="https://unity3d.com/get-unity/download/archive" title="Link to the Unity archive" target="_blank">Unity archive</a>
                find the version of Unity you are using, click on the drop-down menu and download the built-in shaders. I am using 2019.4 at the moment, but it probably isn&rsquo;t
                super important. Besides using the skybox shader, this is a great resource to explore some code and learn how shaders work, so I recommend having a copy of this available
                at any time.
            </p>

            <p class="PageText">
                Once you have downloaded the files create a new Unity project, create a shader and material folder. In the shader folder add another folder and call it <q>Includes</q>.
                Spelling here is important so make sure you name it correctly, or name it whatever you want and make the appropriate changes as we go.
                In the shader folder create a new Unlit shader, name it whatever you want, and open it up. Go ahead and delete everything in the property block, the fog multi-compile line,
                everything from the appdata and v2f structs, all declared variables, and everything out of the vert and frag functions.
            </p>

            <!--https://www.freeformatter.com/html-escape.html#ad-output
    https://prismjs.com/index.html -->
            <div class="CodeHighlight">
<pre>
<code class="language-hlsl line-numbers">Shader &quot;Feral_Pug/SkyBox/MyProceduralSkybox&quot;
{
    Properties
    {

    }
    SubShader
    {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
        LOD 100
        
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include &quot;UnityCG.cginc&quot;

            struct appdata
            {

            };

            struct v2f
            {

            };



            v2f vert (appdata v)
            {

            }

            fixed4 frag (v2f i) : SV_Target
            {

            }
        ENDCG
        }
    }
}</code>
</pre>
                <p class="PageImageText">
                    A gutted shader with the general setup that we will use to build our shader with.
                </p>
            </div>

            <p class="PageText">
                Now go to the file you downloaded and look in the DefaultResourcesExtra folder for the Skybox-Procedural.shader file and open it. We are going to take a lot of this
                code and put it in a separate include file so that our shader doesn&rsquo;t get cluttered. Because Unity doesn&rsquo;t have a way to do this in the editor, go to the
                Includes folder you created outside of Unity and add a text file to that folder and name it <q>Scattering</q>. Then right click it, go to properties, and change the
                <q>.txt</q> file extension to <q>.cginc</q>. Go to Unity and open the <q>Scattering.cginc</q> include file.
            </p>

            <p class="PageText">
                First thing we are going to do is add a define check to make sure we don&rsquo;t ever include this file twice. Add the following to the top of the empty include
                file. This is something you should always do when using include files as including them multiple times will cause redefinition compiler errors.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl line-numbers">#ifndef SCATTERING
    #define SCATTERING

#endif</code>
</pre>
                <p class="PageImageText">
                    A simple way to guard against including a file twice, which will cause an error.
                </p>
            </div>

            <p class="PageText">
                Everything we add to this will go in between the <code>#define SCATTERING</code> and the <code>#endif</code> lines. First, we will grab everything
                from the <code>#if defined(UNITY_COLORSPACE_GAMMA)</code> line to the end of the <code>getRayleighPhase</code> method declaration.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl line-numbers">#ifndef SCATTERING
    #define SCATTERING

        #if defined(UNITY_COLORSPACE_GAMMA)
        #define GAMMA 2
        #define COLOR_2_GAMMA(color) color
        #define COLOR_2_LINEAR(color) color*color
        #define LINEAR_2_OUTPUT(color) sqrt(color)
    #else
        #define GAMMA 2.2
        // HACK: to get gfx-tests in Gamma mode to agree until UNITY_ACTIVE_COLORSPACE_IS_GAMMA is working properly
        #define COLOR_2_GAMMA(color) ((unity_ColorSpaceDouble.r>2.0) ? pow(color,1.0/GAMMA) : color)
        #define COLOR_2_LINEAR(color) color
        #define LINEAR_2_LINEAR(color) color
    #endif

    // RGB wavelengths
    // .35 (.62=158), .43 (.68=174), .525 (.75=190)
    static const float3 kDefaultScatteringWavelength = float3(.65, .57, .475);
    static const float3 kVariableRangeForScatteringWavelength = float3(.15, .15, .15);

    #define OUTER_RADIUS 1.025
    static const float kOuterRadius = OUTER_RADIUS;
    static const float kOuterRadius2 = OUTER_RADIUS * OUTER_RADIUS;
    static const float kInnerRadius = 1.0;
    static const float kInnerRadius2 = 1.0;

    static const float kCameraHeight = 0.0001;

    #define kRAYLEIGH (lerp(0.0, 0.0025, pow(_AtmosphereThickness,2.5)))      // Rayleigh constant
    #define kMIE 0.0010             // Mie constant
    #define kSUN_BRIGHTNESS 20.0    // Sun brightness

    #define kMAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos

    static const half kHDSundiskIntensityFactor = 15.0;
    static const half kSimpleSundiskIntensityFactor = 27.0;

    static const half kSunScale = 400.0 * kSUN_BRIGHTNESS;
    static const float kKmESun = kMIE * kSUN_BRIGHTNESS;
    static const float kKm4PI = kMIE * 4.0 * 3.14159265;
    static const float kScale = 1.0 / (OUTER_RADIUS - 1.0);
    static const float kScaleDepth = 0.25;
    static const float kScaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;
    static const float kSamples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH

    #define MIE_G (-0.990)
    #define MIE_G2 0.9801

    #define SKY_GROUND_THRESHOLD 0.02

    // fine tuning of performance. You can override defines here if you want some specific setup
    // or keep as is and allow later code to set it according to target api

    // if set vprog will output color in final color space (instead of linear always)
    // in case of rendering in gamma mode that means that we will do lerps in gamma mode too, so there will be tiny difference around horizon
    // #define SKYBOX_COLOR_IN_TARGET_COLOR_SPACE 0

    // sun disk rendering:
    // no sun disk - the fastest option
    #define SKYBOX_SUNDISK_NONE 0
    // simplistic sun disk - without mie phase function
    #define SKYBOX_SUNDISK_SIMPLE 1
    // full calculation - uses mie phase function
    #define SKYBOX_SUNDISK_HQ 2

    // uncomment this line and change SKYBOX_SUNDISK_SIMPLE to override material settings
    // #define SKYBOX_SUNDISK SKYBOX_SUNDISK_SIMPLE

    #ifndef SKYBOX_SUNDISK
    #if defined(_SUNDISK_NONE)
        #define SKYBOX_SUNDISK SKYBOX_SUNDISK_NONE
    #elif defined(_SUNDISK_SIMPLE)
        #define SKYBOX_SUNDISK SKYBOX_SUNDISK_SIMPLE
    #else
        #define SKYBOX_SUNDISK SKYBOX_SUNDISK_HQ
    #endif
    #endif

    #ifndef SKYBOX_COLOR_IN_TARGET_COLOR_SPACE
        #if defined(SHADER_API_MOBILE)
            #define SKYBOX_COLOR_IN_TARGET_COLOR_SPACE 1
        #else
            #define SKYBOX_COLOR_IN_TARGET_COLOR_SPACE 0
        #endif
    #endif

    // Calculates the Rayleigh phase function
    half getRayleighPhase(half eyeCos2)
    {
        return 0.75 + 0.75 * eyeCos2;
    }

    half getRayleighPhase(half3 light, half3 ray)
    {
        half eyeCos = dot(light, ray);
        return getRayleighPhase(eyeCos * eyeCos);
    }
#endif</code>
</pre>
                <p class="PageImageText">
                    Everything in between our <q>#define SCATTERING</q> and <q>#endif</q> has been stripped out of the Unity procedural skybox shader and added to our
                    include file. Your include file should look just like this. We have just a few more things to rip out and one or two changes to make to the code.
                </p>
            </div>

            <p class="PageText">
                We still have to rip out the <code>scale</code> function just above the vert method declaration, the <code>getMiePhase</code> method,
                and the <code>calcSunAttenuation</code> method that are just above the frag function. Add those now to the bottom of our include file.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl">float scale(float inCos)
{
    float x = 1.0 - inCos;
    return 0.25 * exp(-0.00287 + x * (0.459 + x * (3.83 + x * (-6.80 + x * 5.25))));
}

// Calculates the Mie phase function
half getMiePhase(half eyeCos, half eyeCos2)
{
    half temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;
    temp = pow(temp, pow(_SunSize, 0.65) * 10);
    temp = max(temp, 1.0e-4); // prevent division by zero, esp. in half precision
    temp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;
    #if defined(UNITY_COLORSPACE_GAMMA) && SKYBOX_COLOR_IN_TARGET_COLOR_SPACE
        temp = pow(temp, .454545);
    #endif
    return temp;
}

// Calculates the sun shape
half calcSunAttenuation(half3 lightPos, half3 ray)
{
    #if SKYBOX_SUNDISK == SKYBOX_SUNDISK_SIMPLE
        half3 delta = lightPos - ray;
        half dist = length(delta);
        half spot = 1.0 - smoothstep(0.0, _SunSize, dist);
        return spot * spot;
    #else // SKYBOX_SUNDISK_HQ
        half focusedEyeCos = pow(saturate(dot(lightPos, ray)), _SunSizeConvergence);
        return getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);
    #endif
}</code>
</pre>
                <p class="PageImageText">
                    Almost finished with setting up the include file. It seems like a lot of work, but it will be much nicer to work with our shader once this
                    is all out of the way.
                </p>
            </div>

            <p class="PageText">
                All we have left to do is change a few of the methods. Some of the methods reference properties on our shader. While this is not really a problem, your IDE,
                like Visual Studio, will keep complaining about it and I find it very annoying. All we have to do is replace these with parameters we will add to these functions
                and then remember to add those parameters to where they are used in the shader.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl">float scale(float inCos)
{
    float x = 1.0 - inCos;
    return 0.25 * exp(-0.00287 + x * (0.459 + x * (3.83 + x * (-6.80 + x * 5.25))));
}

// Calculates the Mie phase function
half getMiePhase(half eyeCos, half eyeCos2<span class="addition">, float SunSize</span>)
{
    half temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;
    temp = pow(temp, pow(<span class="addition">SunSize</span>, 0.65) * 10);
    temp = max(temp, 1.0e-4); // prevent division by zero, esp. in half precision
    temp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;
    #if defined(UNITY_COLORSPACE_GAMMA) && SKYBOX_COLOR_IN_TARGET_COLOR_SPACE
        temp = pow(temp, .454545);
    #endif
    return temp;
}

// Calculates the sun shape
half calcSunAttenuation(half3 lightPos, half3 ray<span class="addition">, float SunSize, float SunSizeConvergence</span>)
{
    #if SKYBOX_SUNDISK == SKYBOX_SUNDISK_SIMPLE
        half3 delta = lightPos - ray;
        half dist = length(delta);
        half spot = 1.0 - smoothstep(0.0, <span class="addition">SunSize</span>, dist);
        return spot * spot;
    #else // SKYBOX_SUNDISK_HQ
        half focusedEyeCos = pow(saturate(dot(lightPos, ray)), <span class="addition">SunSizeConvergence</span>);
        return getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos<span class="addition">, SunSize</span>);
    #endif
}</code>
</pre>
                <p class="PageImageText">
                    And we are done. We have just made the highlighted changes to our include file. You can close this and never look at it again.
                </p>
            </div>

            <p class="PageText">
                Now the last thing we have to do to recreate the Unity procedural skybox and get to extending it is to change the rendering mode, queue and preview, set Cull and Zwrite to off,
                add all the properties, include files, pragma statements, property variable declarations, vert and fragment data structures, and the vert and frag programs themselves.
            </p>

            <p class="PageText">
                First, we change the rendering queue and type to <q>Background</q>. This is to tell the shader to render this first. In Unity, what ever the background is for the camera gets
                rendered first, so that any pixel that does not get drawn will at least get the background drawn there. If our camera is set to draw the skybox as the background, Unity will
                hook up the camera with the skybox material and draw it accordingly. The preview tag just changes how it&rsquo;s preview looks in the inspector.
            </p>

            <p class="PageText">
                We do not to want cull any part of skybox. I am not exactly sure how Unity draws the Skybox. My guess is that it draws a mesh that is equal to the view frustrum of the
                camera, and so we would likely be drawing back faces. But if Unity sets their skybox to have no culling we will do the same. They probably know better. We also do not want
                to write to the Zbuffer as we would want any geometry or transparent objects in the view of the camera to draw instead of the skybox. It probably doesn&rsquo;t matter as
                anything beyond the skybox should be out of the camera&rsquo;s view, but I suppose it saves the render pipeline from having to write to the z-buffer. 
            </p>

            <p class="PageText">
                We also need to include our <q>Scattering.cginc</q> file as that is where all the functions now live and we also have to add the <q>_SunSize</q>
                and <q>_SunSizeConvergence</q> to the parameters list for the <q>calcSunAttenuation</q> method call in the frag function.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl line-numbers">Shader &quot;Feral_Pug/SkyBox/MyProceduralSkybox&quot;
{
    Properties
    {
        <span class="addition">[KeywordEnum(None, Simple, High Quality)] _SunDisk ("Sun", Int) = 2
        _SunSize ("Sun Size", Range(0,1)) = 0.04
        _SunSizeConvergence("Sun Size Convergence", Range(1,10)) = 5

        _AtmosphereThickness ("Atmosphere Thickness", Range(0,5)) = 1.0
        _SkyTint ("Sky Tint", Color) = (.5, .5, .5, 1)
        _GroundColor ("Ground", Color) = (.369, .349, .341, 1)

        _Exposure("Exposure", Range(0, 8)) = 1.3</span>

    }
    SubShader
    {
        <span class="addition">Tags { "Queue"="Background" "RenderType"="Background" "PreviewType"="Skybox" }
        Cull Off ZWrite Off</span>
    
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include &quot;UnityCG.cginc&quot;
            <span class="addition">#include &quot;Lighting.cginc&quot;
            #include &quot;Includes/Scattering.cginc&quot;

            #pragma multi_compile_local _SUNDISK_NONE _SUNDISK_SIMPLE _SUNDISK_HIGH_QUALITY

            uniform half _Exposure;     // HDR exposure
            uniform half3 _GroundColor;
            uniform half _SunSize;
            uniform half _SunSizeConvergence;
            uniform half3 _SkyTint;
            uniform half _AtmosphereThickness;</span>

            struct appdata
            {
                <span class="addition">float4 vertex : POSITION;
                UNITY_VERTEX_INPUT_INSTANCE_ID</span>
            };

            struct v2f
            {
                <span class="addition">float4  pos             : SV_POSITION;

                #if SKYBOX_SUNDISK == SKYBOX_SUNDISK_HQ
                    // for HQ sun disk, we need vertex itself to calculate ray-dir per-pixel
                    float3  vertex          : TEXCOORD0;
                #elif SKYBOX_SUNDISK == SKYBOX_SUNDISK_SIMPLE
                    half3   rayDir          : TEXCOORD0;
                #else
                    // as we dont need sun disk we need just rayDir.y (sky/ground threshold)
                    half    skyGroundFactor : TEXCOORD0;
                #endif

                // calculate sky colors in vprog
                half3   groundColor     : TEXCOORD1;
                half3   skyColor        : TEXCOORD2;

                #if SKYBOX_SUNDISK != SKYBOX_SUNDISK_NONE
                    half3   sunColor        : TEXCOORD3;
                #endif

                UNITY_VERTEX_OUTPUT_STEREO</span>
            };

            v2f vert (appdata v)
            {
                <span class="addition">v2f OUT;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);
                OUT.pos = UnityObjectToClipPos(v.vertex);

                float3 kSkyTintInGammaSpace = COLOR_2_GAMMA(_SkyTint); // convert tint from Linear back to Gamma
                float3 kScatteringWavelength = lerp (
                    kDefaultScatteringWavelength-kVariableRangeForScatteringWavelength,
                    kDefaultScatteringWavelength+kVariableRangeForScatteringWavelength,
                    half3(1,1,1) - kSkyTintInGammaSpace); // using Tint in sRGB gamma allows for more visually linear interpolation and to keep (.5) at (128, gray in sRGB) point
                float3 kInvWavelength = 1.0 / pow(kScatteringWavelength, 4);

                float kKrESun = kRAYLEIGH * kSUN_BRIGHTNESS;
                float kKr4PI = kRAYLEIGH * 4.0 * 3.14159265;

                float3 cameraPos = float3(0,kInnerRadius + kCameraHeight,0);    // The camera's current position

                // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
                float3 eyeRay = normalize(mul((float3x3)unity_ObjectToWorld, v.vertex.xyz));

                float far = 0.0;
                half3 cIn, cOut;

                if(eyeRay.y >= 0.0)
                {
                    // Sky
                    // Calculate the length of the "atmosphere"
                    far = sqrt(kOuterRadius2 + kInnerRadius2 * eyeRay.y * eyeRay.y - kInnerRadius2) - kInnerRadius * eyeRay.y;

                    float3 pos = cameraPos + far * eyeRay;

                    // Calculate the ray's starting position, then calculate its scattering offset
                    float height = kInnerRadius + kCameraHeight;
                    float depth = exp(kScaleOverScaleDepth * (-kCameraHeight));
                    float startAngle = dot(eyeRay, cameraPos) / height;
                    float startOffset = depth*scale(startAngle);


                    // Initialize the scattering loop variables
                    float sampleLength = far / kSamples;
                    float scaledLength = sampleLength * kScale;
                    float3 sampleRay = eyeRay * sampleLength;
                    float3 samplePoint = cameraPos + sampleRay * 0.5;

                    // Now loop through the sample rays
                    float3 frontColor = float3(0.0, 0.0, 0.0);
                    // Weird workaround: WP8 and desktop FL_9_3 do not like the for loop here
                    // (but an almost identical loop is perfectly fine in the ground calculations below)
                    // Just unrolling this manually seems to make everything fine again.
    //              for(int i=0; i&lt;int(kSamples); i++)
                    {
                        float height=length(samplePoint);
                        float depth=exp(kScaleOverScaleDepth * (kInnerRadius - height));
                        float lightAngle=dot(_WorldSpaceLightPos0.xyz, samplePoint) / height;
                        float cameraAngle=dot(eyeRay, samplePoint) / height;
                        float scatter=(startOffset + depth*(scale(lightAngle) - scale(cameraAngle)));
                        float3 attenuate=exp(-clamp(scatter, 0.0, kMAX_SCATTER) * (kInvWavelength * kKr4PI + kKm4PI));
                        frontColor +=attenuate * (depth * scaledLength);
                        >samplePoint +=sampleRay;
                    }
                    {
                        float height=length(samplePoint);
                        float depth=exp(kScaleOverScaleDepth * (kInnerRadius - height));
                        float lightAngle=dot(_WorldSpaceLightPos0.xyz, samplePoint) / height;
                        float cameraAngle=dot(eyeRay, samplePoint) / height;
                        float scatter=(startOffset + depth*(scale(lightAngle) - scale(cameraAngle)));
                        float3 attenuate=exp(-clamp(scatter, 0.0, kMAX_SCATTER) * (kInvWavelength * kKr4PI + kKm4PI));
                        frontColor +=attenuate * (depth * scaledLength);
                        samplePoint +=sampleRay;
                    }
                    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader
                    cIn=frontColor * (kInvWavelength * kKrESun);
                    cOut=frontColor * kKmESun;
                }
                else
                {
                    // Ground
                    far=(-kCameraHeight) / (min(-0.001, eyeRay.y));
                    float3 pos=cameraPos + far * eyeRay;
                    // Calculate the ray's starting position, then calculate its scattering offset
                    float depth=exp((-kCameraHeight) * (1.0 /kScaleDepth));
                    float cameraAngle=dot(-eyeRay, pos);
                    float lightAngle=dot(_WorldSpaceLightPos0.xyz, pos);
                    float cameraScale=scale(cameraAngle);
                    float lightScale=scale(lightAngle);
                    float cameraOffset=depth*cameraScale;
                    float temp=(lightScale + cameraScale);
                    // Initialize the scattering loop variables
                    float sampleLength=far / kSamples;
                    float scaledLength=sampleLength * kScale;
                    float3 sampleRay=eyeRay * sampleLength;
                    float3 samplePoint=cameraPos + sampleRay * 0.5;
                    // Now loop through the sample rays
                    float3 frontColor=float3(0.0, 0.0, 0.0);
                    float3 attenuate;
                // for(int i=0; i&lt;int(kSamples); i++) // Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.
                    {
                        float height = length(samplePoint);
                        float depth = exp(kScaleOverScaleDepth * (kInnerRadius - height));
                        float scatter = depth*temp - cameraOffset;
                        attenuate = exp(-clamp(scatter, 0.0, kMAX_SCATTER) * (kInvWavelength * kKr4PI + kKm4PI));
                        frontColor += attenuate * (depth * scaledLength)
                        samplePoint += sampleRay;
                    }

                    cIn = frontColor * (kInvWavelength * kKrESun + kKmESun);
                    cOut = clamp(attenuate, 0.0, 1.0);
                }

                #if SKYBOX_SUNDISK == SKYBOX_SUNDISK_HQ
                    OUT.vertex          = -eyeRay;
                #elif SKYBOX_SUNDISK == SKYBOX_SUNDISK_SIMPLE
                    OUT.rayDir          = half3(-eyeRay);
                #else
                    OUT.skyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;
                #endif

                // if we want to calculate color in vprog:
                // 1. in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)
                // 2. in case of gamma and SKYBOX_COLOR_IN_TARGET_COLOR_SPACE: do sqrt right away instead of doing that in fshader

                OUT.groundColor = _Exposure * (cIn + COLOR_2_LINEAR(_GroundColor) * cOut);
                OUT.skyColor    = _Exposure * (cIn * getRayleighPhase(_WorldSpaceLightPos0.xyz, -eyeRay));

                #if SKYBOX_SUNDISK != SKYBOX_SUNDISK_NONE
                    // The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.
                    // This matching was done using the standard shader BRDF1 on the 5/31/2017
                    // Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.
                    half lightColorIntensity = clamp(length(_LightColor0.xyz), 0.25, 1);
                    #if SKYBOX_SUNDISK == SKYBOX_SUNDISK_SIMPLE
                        OUT.sunColor    = kSimpleSundiskIntensityFactor * saturate(cOut * kSunScale) * _LightColor0.xyz / lightColorIntensity;
                    #else // SKYBOX_SUNDISK_HQ
                        OUT.sunColor    = kHDSundiskIntensityFactor * saturate(cOut) * _LightColor0.xyz / lightColorIntensity;
                    #endif

                #endif

                #if defined(UNITY_COLORSPACE_GAMMA) && SKYBOX_COLOR_IN_TARGET_COLOR_SPACE
                    OUT.groundColor = sqrt(OUT.groundColor);
                    OUT.skyColor    = sqrt(OUT.skyColor);
                    #if SKYBOX_SUNDISK != SKYBOX_SUNDISK_NONE
                        OUT.sunColor= sqrt(OUT.sunColor);
                    #endif
                #endif

                return OUT;</span>
            }

            fixed4 frag (v2f <span class="addition">IN</span>) : SV_Target
            {
                <span class="addition">half3 col = half3(0.0, 0.0, 0.0);

                // if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground
                // if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon
                // if y < 0 [eyeRay.y > 0] - sky
                #if SKYBOX_SUNDISK == SKYBOX_SUNDISK_HQ
                    half3 ray = normalize(IN.vertex.xyz);
                    half y = ray.y / SKY_GROUND_THRESHOLD;
                #elif SKYBOX_SUNDISK == SKYBOX_SUNDISK_SIMPLE
                    half3 ray = IN.rayDir.xyz;
                    half y = ray.y / SKY_GROUND_THRESHOLD;
                #else
                    half y = IN.skyGroundFactor;
                #endif

                // if we did precalculate color in vprog: just do lerp between them
                col = lerp(IN.skyColor, IN.groundColor, saturate(y));

                #if SKYBOX_SUNDISK != SKYBOX_SUNDISK_NONE
                    if(y < 0.0)
                    {
                        col += IN.sunColor * calcSunAttenuation(_WorldSpaceLightPos0.xyz, -ray, _SunSize, _SunSizeConvergence);
                    }
                #endif

                #if defined(UNITY_COLORSPACE_GAMMA) && !SKYBOX_COLOR_IN_TARGET_COLOR_SPACE
                    col = LINEAR_2_OUTPUT(col);
                #endif

                return half4(col,1.0);</span>
            }
        ENDCG
        }
    }
}</code>
</pre>
                <p class="PageImageText">
                    Now we have a cleaned-up version of the Unity procedural skybox shader and we can finally start to get to work. Do not forget to add those parameters
                    to the <q>calcSunAttenuation</q> call in the frag function.
                </p>
            </div>

            <p class="PageText">
                OK, now we are finished with setting up our shader. I know that was a lot so if you want you can just grab the completed version of this step from my
                GitHub <a href="https://github.com/FeralPug/FeralPug-Extending-the-Unity-Skybox/tree/main/EndOfPart2%20Setup" title="A link to where you can download the finished files for this step" target="_blank">here</a>.
                Just remember the include file has to go into a folder named <q>Includes</q> in the same directory as the shader
                or you will have to change the file path on the include statement for our <q>Scattering.cginc</q> include file.
            </p>

            <h2 class="Section" id="Part3">Part 3: Adding Stars</h2>

            <p class="PageText">
                The first thing we will add is stars. This is relatively simple, so it seems like a good place to start. To get stars we will use a Voronoi texture. You can
                easily make one yourself in whatever software you like, I use GIMP, or you can use the one I made by going to my GitHub
                <a href="https://github.com/FeralPug/FeralPug-Extending-the-Unity-Skybox/blob/main/Textures/TilesVoronoi.png" title="Link to a Voronoi Texture" target="_blank">here</a>.
                In GIMP all you have to do is create a new image and go to <strong>Filters</strong> > <strong>Render</strong> > <strong>Noise</strong> > <strong>Cell Noise</strong>. Play around
                with the settings until you have one you like. Then when you are done go back to <strong>Filters</strong> and find <strong>Map</strong> > <strong>Tile Seamless</strong>.
                Keep the opacity at 100 and hit OK. Export it as you like, and you are all set to go. When you are done import it into Unity.
            </p>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/TilesVoronoi.png" alt="Voronoi Texture use for creating stars" />
                <p class="PageImageText">
                    This is the Voronoi Texture that I used.
                </p>
            </div>

            <p class="PageText">
                To be able to use this texture we have to come up with a way to get UVs to sample the texture within our shader. To do this we will get the
                world space position of the current pixel we are working on, normalize it, and use that direction generate UV coordinates. I have seen lots of examples of turning
                this direction into spherical coordinates using some trigonometry, which we will do when we make our moon, but this makes for bad samples around the poles. A better way,
                and a lot simpler, is to just divide the and X and Z coordinates of our direction by the Y of our direction. This essentially projects our direction on to a plane
                that sits directly on top of the sphere we are calling our skybox and is orientated facing up. And we can take this one step further. By adding a number between
                0 and 1 to the Y coordinate before the division we can make this plane curve in a way that gives us control over how the stars are in the sky.
            </p>
            <p class="PageText">
                To do that we will add a bending amount property along with a texture property and declare those variables. While we are at it, we will clean up the
                property block a bit. Next, we will have to change our <q>v2f</q> struct a bit so we can pass the world position from the vertex shader to the fragment shader.
                Then in the fragment shader we can get the direction, do the division, and finally sample the texture. For now, we will just use a test texture to see it in action.
                You can get that texture <a href="https://github.com/FeralPug/FeralPug-Extending-the-Unity-Skybox/blob/main/Textures/TestTexture.jpg" title="link to test texture" target="_blank">here</a>.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl">Properties
    {
        <span class="addition">[Header(SkyAndSun)]</span>
        [KeywordEnum(None, Simple, High Quality)] _SunDisk ("Sun", Int) = 2
        _SunSize ("Sun Size", Range(0,1)) = 0.04
        _SunSizeConvergence("Sun Size Convergence", Range(1,10)) = 5
        _AtmosphereThickness ("Atmosphere Thickness", Range(0,5)) = 1.0
        _SkyTint ("Sky Tint", Color) = (.5, .5, .5, 1)
        _GroundColor ("Ground", Color) = (.369, .349, .341, 1)
        _Exposure("Exposure", Range(0, 8)) = 1.3

        <span class="addition">[Header (Stars)]
        _StarTex("Star Tex", 2D) = "black" {}
        _StarBending("Star Bending", Range(0, 1)) = 1</span>
    }

...

    uniform half _Exposure;     // HDR exposure
    uniform half3 _GroundColor;
    uniform half _SunSize;
    uniform half _SunSizeConvergence;
    uniform half3 _SkyTint;
    uniform half _AtmosphereThickness;

    <span class="addition">uniform sampler2D _StarTex;
    uniform float4 _StarTex_ST;
    uniform float _StarBending;</span>

    struct appdata
    {
        float4 vertex : POSITION;
        UNITY_VERTEX_INPUT_INSTANCE_ID
    };
    
    struct v2f
    {
        float4  pos             : SV_POSITION;
            <span class="addition">float3 worldPos : TEXCOORD0;</span>
        #if SKYBOX_SUNDISK == SKYBOX_SUNDISK_HQ
        // for HQ sun disk, we need vertex itself to calculate ray-dir per-pixel
            float3  vertex          : TEXCOORD<span class="addition">1</span>;
        #elif SKYBOX_SUNDISK == SKYBOX_SUNDISK_SIMPLE
            half3   rayDir          : TEXCOORD<span class="addition">1;</span>
        #else
            // as we dont need sun disk we need just rayDir.y (sky/ground threshold)
            half    skyGroundFactor : TEXCOORD<span class="addition">1</span>;
        #endif

        // calculate sky colors in vprog
        half3   groundColor     : TEXCOORD<span class="addition">2</span>;
        half3   skyColor        : TEXCOORD<span class="addition">3</span>;

        #if SKYBOX_SUNDISK != SKYBOX_SUNDISK_NONE
            half3   sunColor        : TEXCOORD<span class="addition">4</span>;
        #endif

        UNITY_VERTEX_OUTPUT_STEREO
    };

    v2f vert (appdata v)
    {
        v2f OUT;
        UNITY_SETUP_INSTANCE_ID(v);
        UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);
        OUT.pos = UnityObjectToClipPos(v.vertex);
        <span class="addition">OUT.worldPos = mul(unity_ObjectToWorld, v.vertex);</span>

        float3 kSkyTintInGammaSpace = COLOR_2_GAMMA(_SkyTint); // convert tint from Linear back to Gamma
        float3 kScatteringWavelength = lerp (
    
...

    fixed4 frag (v2f IN) : SV_Target
    {
        <span class="addition">//first off we declare some values and set up some stuff that will get used a lot in the shader
        float4 col = float4(0, 0, 0, 0);

        //first off we have to make our positions fit a sphere
        float3 normWorldPos = normalize(IN.worldPos);

    //Start of Unity code</span>
        // if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground
        // if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon
        // if y < 0 [eyeRay.y > 0] - sky
        #if SKYBOX_SUNDISK == SKYBOX_SUNDISK_HQ
            half3 ray = normalize(IN.vertex.xyz);
            half y = ray.y / SKY_GROUND_THRESHOLD;
        #elif SKYBOX_SUNDISK == SKYBOX_SUNDISK_SIMPLE
            half3 ray = IN.rayDir.xyz;
            half y = ray.y / SKY_GROUND_THRESHOLD;
        #else
            half y = IN.skyGroundFactor;
        #endif

            // if we did precalculate color in vprog: just do lerp between them
                <span class="addition">col.rgb</span> = lerp(IN.skyColor, IN.groundColor, saturate(y));

        #if SKYBOX_SUNDISK != SKYBOX_SUNDISK_NONE
            if(y < 0.0)
            {
                <span class="addition">col.rgb</span> += IN.sunColor * calcSunAttenuation(_WorldSpaceLightPos0.xyz, -ray, _SunSize, _SunSizeConvergence);
            }
        #endif

        #if defined(UNITY_COLORSPACE_GAMMA) && !SKYBOX_COLOR_IN_TARGET_COLOR_SPACE
            <span class="addition">col.rgb</span> = LINEAR_2_OUTPUT(col);
        #endif

    <span class="addition">//End of Unity Code

    //Stars
        float2 starsUV = normWorldPos.xz / (normWorldPos.y + _StarBending);
        col.rgb = tex2D(_StarTex, starsUV * _StarTex_ST.xy + _StarTex_ST.zw).rgb;
    
        return col;</span>
    }</code>
</pre>
            </div>


            <div class="PageImageContainer">
                <div class="ImageSideBySideContainer">
                    <img class="PageSideBySide" src="Media/StarBending0.png" alt="Picture of our projected texture" />
                    <img class="PageSideBySide" src="Media/StarBending1.png" alt="Picture of our projected texture" />
                </div>
                <p class="PageImageText">
                    On the left _StarsBending is set to 0 and on the right _StarsBending is set to 1
                </p>
            </div>

            <p class="PageText">
                Now to get the actual stars we will switch to using our Voronoi texture and take the value at our texture sample, invert it with a <q>1 - value</q>
                and then raise it to a power to get tight little dots in the sky. While we are at it let also add some new properties to control where the horizon
                starts to mask out all of the features we are going to add because we do not want to be able to see them under the horizon anyway. To do that we take the
                dot product of our world direction and an up vector, remap that value so that at our user set values it goes from 0 to 1 and then invert the value so 1 is
                on top and zero is at the bottom. We can then use the 0 to 1 value to lerp between the background color and our added features. Once done play with the values
                a bit to get what you like.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl">Properties
{
    [Header(SkyAndSun)]
    [KeywordEnum(None, Simple, High Quality)] _SunDisk ("Sun", Int) = 2
    _SunSize ("Sun Size", Range(0,1)) = 0.04
    _SunSizeConvergence("Sun Size Convergence", Range(1,10)) = 5
    _AtmosphereThickness ("Atmosphere Thickness", Range(0,5)) = 1.0
    _SkyTint ("Sky Tint", Color) = (.5, .5, .5, 1)
    _GroundColor ("Ground", Color) = (.369, .349, .341, 1)
    _Exposure("Exposure", Range(0, 8)) = 1.3
    <span class="addition">_SkyFadeStart("Sky Fade Start", Range(-1, 1)) = .05
    _SkyFadeEnd("Sky End Start", Range(-1, 1)) = -.05</span>

    [Header (Stars)]
    _StarTex("Star Tex", 2D) = "black" {}
    _StarBending("Star Bending", Range(0, 1)) = 1
    <span class="addition">_StarBrightness("Star Brightness", Range(0, 100)) = 8.5</span>
}

...

    uniform half _Exposure;     // HDR exposure
    uniform half3 _GroundColor;
    uniform half _SunSize;
    uniform half _SunSizeConvergence;
    uniform half3 _SkyTint;
    uniform half _AtmosphereThickness;
    <span class="addition">uniform half _SkyFadeStart, _SkyFadeEnd;</span>

    uniform sampler2D _StarTex;
    uniform float4 _StarTex_ST;
    uniform float _StarBending, <span class="addition">_StarBrightness;</span>

...

    <span class="addition">float Remap(float In, float2 InMinMax, float2 OutMinMax)
    {
        return OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
    }</span>

    fixed4 frag (v2f IN) : SV_Target
    {
        //first off we declare some values and set up some stuff that will get used a lot in the shader
        float4 col = float4(0, 0, 0, 0);

        //first off we have to make our positions fit a sphere
        float3 normWorldPos = normalize(IN.worldPos);

        <span class="addition">//this sets up where things will start to fade out along the horizon. The values allow us to give it some range so it fades out
        //we have to do 1 minus because the start fade value is actauly higher then the end. You could do the dot with down but I like this better
        float horizonValue = dot(normWorldPos, float3(0, 1, 0));
        horizonValue = 1 - saturate(Remap(horizonValue, float2(_SkyFadeStart, _SkyFadeEnd), float2(0, 1)));</span>

...

    //Stars
        float2 starsUV = normWorldPos.xz / (normWorldPos.y + _StarBending);
        <span class="addition">float stars</span> = tex2D(_StarTex, starsUV * _StarTex_ST.xy + _StarTex_ST.zw).<span class="addition">r;
        //invert the voronoi
        stars = 1 - stars;
        //and then raise the value to a power to adjust the brightness falloff of the stars
        stars = pow(stars, _StarBrightness);

        //then lerp to the stars color masking out the horizon
        col.rgb = lerp(col.rgb, col.rgb + stars, horizonValue);</span>

        return col;</code>
</pre>
            </div>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/Stars.png" alt="Our Stary sky" />
                <p class="PageImageText"> Stars!!!</p>
            </div>

            <p class="PageText">
                Now to give our stars a little more life, we will make them twinkle. To do this we will sample a noise texture using the same uvs we used to sample the
                voronoi texture. Then, multiply it by a user controlled value, and finally subtract that from our <code>stars</code> value. We will also <code>saturate</code>
                the <code>stars</code> value before doing the <code>lerp</code> to clamp everything between 0 and 1. You can get the texture I used
                <a href="https://github.com/FeralPug/FeralPug-Extending-the-Unity-Skybox/blob/main/Textures/starsHighlight.png" title="Link to noise texture" target="_blank">here</a>.
                Add the following code to your shader.
            </p>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/starsHighlight.png" alt="Noise texture" />
                <p class="PageImageText"> Noise texture used to create a twinkle effect on the stars</p>
            </div>

<div class="CodeHighlight">
<pre>
<code class="language-hlsl">    _SkyFadeStart("Sky Fade Start", Range(-1, 1)) = .05
    _SkyFadeEnd("Sky End Start", Range(-1, 1)) = -.05

    [Header (Stars)]
    _StarTex("Star Tex", 2D) = "black" {}
    _StarBending("Star Bending", Range(0, 1)) = 1
    _StarBrightness("Star Brightness", Range(0, 100)) = 8.5
    <span class="addition">_TwinkleTex ("Twinkle Noise Tex", 2D) = "black" {}
    _TwinkleBoost("Twinkle Boost", Range(0, 1)) = .25
    _TwinkleSpeed("Twinkle Speed", Range(0, 1)) = .1</span>

...

    uniform half _SkyFadeStart, _SkyFadeEnd;

    uniform sampler2D _StarTex, <span class="addition">_TwinkleTex;</span>
    uniform float4 _StarTex_ST, <span class="addition">_TwinkleTex_ST;</span>
    uniform float _StarBending, _StarBrightness;
    <span class="addition">uniform float _TwinkleBoost, _TwinkleSpeed;</span>

...

    float2 starsUV = normWorldPos.xz / (normWorldPos.y + _StarBending);
    float stars = tex2D(_StarTex, starsUV * _StarTex_ST.xy + _StarTex_ST.zw).r;
    //invert the voronoi
    stars = 1 - stars;
    //and then raise the value to a power to adjust the brightness falloff of the stars
    stars = pow(stars, _StarBrightness);

    <span class="addition">//we also sample a basic noise texture, this allows us to modulate the star brightness, this creates a twinkle effect
    float twinkle = tex2D(_TwinkleTex, (starsUV * _TwinkleTex_ST.xy) + _TwinkleTex_ST.zw + float2(1, 0) * _Time.y * _TwinkleSpeed).r;
    //modulate the twinkle value
    twinkle *= _TwinkleBoost;
                
    //then adjust the final color
    stars -= twinkle;
    stars = saturate(stars);</span>

    //then lerp to the stars color masking out the horizon
    col.rgb = lerp(col.rgb, col.rgb + stars, horizonValue);
</code>
</pre>
</div>

                                <div class="PageImageContainer">
                        <img class="PageImage" src="Media/StarTwinkle.gif" alt="Gif of stars twinkling" />
                        <p class="PageImageText"> Twinkle twinkle procedural star</p>
                    </div>

            <p class="PageText">
                Once last addition we will make is a way to transition our added features from day to night, as somethings like stars should really only by visible
                during the night. To do that we will again add a few more properties, declare their variables, and then do almost exactly what we did for our horizon value
                except we will use the position of the sun instead of our world direction. Since we will use the sun position in a few places we will store it in a nicely named
                variable and use that instead of Unity&rsquo;s <q>_WorldSpaceLightPos0.xyz</q> as that is kind of annoying to write out all the time. Then we can use our calculated
                night value to affect how we lerp to the final color.
            </p>

            <div class="CodeHighlight">
<pre>
    <code class="language-hlsl">[Header(SkyAndSun)]
    [KeywordEnum(None, Simple, High Quality)] _SunDisk ("Sun", Int) = 2
    _SunSize ("Sun Size", Range(0,1)) = 0.04
    _SunSizeConvergence("Sun Size Convergence", Range(1,10)) = 5
    _AtmosphereThickness ("Atmosphere Thickness", Range(0,5)) = 1.0
    _SkyTint ("Sky Tint", Color) = (.5, .5, .5, 1)
    _GroundColor ("Ground", Color) = (.369, .349, .341, 1)
    _Exposure("Exposure", Range(0, 8)) = 1.3
    <span class="addition">_NightStartHeight("Night Start Height", Range(-1, 1)) = -.1
    _NightEndHeight("Night End Height", Range(-1, 1)) = -.2</span>
    _SkyFadeStart("Sky Fade Start", Range(-1, 1)) = .05
    _SkyFadeEnd("Sky End Start", Range(-1, 1)) = -.05

...

    uniform half _Exposure;     // HDR exposure
    uniform half3 _GroundColor;
    uniform half _SunSize;
    uniform half _SunSizeConvergence;
    uniform half3 _SkyTint;
    uniform half _AtmosphereThickness;
    <span class="addition">uniform half _NightStartHeight, _NightEndHeight;</span>
    uniform half _SkyFadeStart, _SkyFadeEnd;

...

    //this sets up where things will start to fade out along the horizon. The values allow us to give it some range so it fades out
    //we have to do 1 minus because the start fade value is actauly higher then the end. You could do the dot with down but I like this better
    float horizonValue = dot(normWorldPos, float3(0, 1, 0));
    horizonValue = 1 - saturate(Remap(horizonValue, float2(_SkyFadeStart, _SkyFadeEnd), float2(0, 1)));

    <span class="addition">//grab the sun position
    float3 sunPos = _WorldSpaceLightPos0.xyz;

    //and then do a similar method as the horizon to figure out when things should transistion to the night colors
    float sunDotUp = dot(sunPos, float3(0, 1, 0));
    float night = saturate(Remap(sunDotUp, float2(_NightStartHeight, _NightEndHeight), float2(0, 1)));</span>

...

    #if SKYBOX_SUNDISK != SKYBOX_SUNDISK_NONE
        if(y < 0.0)
        {
            col.rgb += IN.sunColor * calcSunAttenuation(<span class="addition">sunPos</span>, -ray, _SunSize, _SunSizeConvergence);
        }
    #endif

...

    float2 starsUV = normWorldPos.xz / (normWorldPos.y + _StarBending);
    float stars = tex2D(_StarTex, starsUV * _StarTex_ST.xy + _StarTex_ST.zw).r;
    //invert the voronoi
    stars = 1 - stars;
    //and then raise the value to a power to adjust the brightness falloff of the stars
    stars = pow(stars, _StarBrightness);

    //then lerp to the stars color masking out the horizon
    col.rgb = lerp(col.rgb, col.rgb + stars, <span class="addition">night * </span>horizonValue);
    
    return col;
    </code>
</pre>
            </div>

            <div class="PageImageContainer">
                <div class="ImageSideBySideContainer">
                    <img class="PageSideBySide" src="Media/Stars.png" alt="Our stars at night" />
                    <img class="PageSideBySide" src="Media/NoStars.png" alt="No stars during the day" />
                </div>
                <p class="PageImageText">
                    On the left we have stars at night and on the right we have no stars during the day
                </p>
            </div>

            <p class="PageText">
                And with that our stars are done for the most part. All we will have to do in future steps is to make sure we mask them out accordingly with the other features
                we will add. If you want you can grab the finished files for this step
                <a href="https://github.com/FeralPug/FeralPug-Extending-the-Unity-Skybox/tree/main/Part%20Three:%20Stars" title="Link to completed step" target="_blank">here</a>.
                Next we will work on the procedural moon.
            </p>

            <h2 class="Section" id="Part4">Part 4: Adding a Moon</h2>

            <p class="PageText">
                To create a moon for our skybox there are a few different ways we could go, and it depends on what we specifically want. For this skybox I mainly
                wanted a moon that could be textured. That was really the inspiration behind making this shader. But it should also be able to orbit around
                the sky in any orientation, that could change size to simulate eccentric orbits, spin, customizable moon phases, and have the option for being
                tidal locked, or always facing in the same direction. I tried a few different methods to get this to work but the best way to achieve this is to
                create a fake sphere in the skybox that we can create normals for. By manipulating those normals we can get a lot of cool stuff to happen.
            </p>

            <p class="PageText">
                Since this is going to require a lot of functions, we are going to create another include file to hold all of these functions. So once again, create a new
                text file outside of Unity in our <q>Includes</q> folder, and change the file extension to <q>.cginc</q>. Then we will add our include guard to the top
                of our include file. I named my include file <q>MoonFunctions.cginc</q> but feel free to name yours whatever you like, just make the appropriate changes
                in your code.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl line-numbers">#ifndef MOON_INCLUDE
    #define MOON_INCLUDE

#endif
</code>
</pre>
                <p class="PageImageText">
                    This is the start of our <q>MoonFunctions.cginc</q> include file.
                </p>
            </div>

            <p class="PageText">
                The first thing we will add to this is method for creating the actual moon. To do this we will use some math called ray-surface intersection.
                There is a lot of info on the internet about this and you can find a lot more of these functions, and the one we will be using,
                <a href="https://www.iquilezles.org/www/articles/intersectors/intersectors.htm" title="Link to more intersector functions" target="_blank">here</a>.
                We will be using the sphere function, as we are making a moon, but I suppose you could create some cool skies with some of the other functions. So
                add the SphereIntersect function to our include file in between the preprocessor directives just like we did with the last include file.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl line-numbers">#ifndef MOON_INCLUDE
    #define MOON_INCLUDE

    //sphere tracing from https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
    float SphereIntersect(float3 rayOrigin, float3 rayDirection, float3 spherePos, float sphereRadius)
    {
        float3 originToCenter = rayOrigin - spherePos;
        float b = dot(originToCenter, rayDirection);
        float c = dot(originToCenter, originToCenter) - sphereRadius * sphereRadius;
        float h = b * b - c;
        if (h < 0.0)
        {
            return -1.0;
        }
        h = sqrt(h);
        return -b - h;
    }

#endif</code>
</pre>
            </div>

            <p class="PageText">
                This function will return the distance to the sphere from wherever the origin of the ray is, or if the ray does not intersect with the sphere, it will return
                -1.0. In our shader we will use this value to either draw the moon or not draw the moon. If we are working on a pixel that should have the moon draw, we can use
                the returned value to figure out exactly in would space the surface of the moon is. We can then use that to calculate a normal direction for the sphere by
                subtracting the moon&rsquo;s origin from the surface position we calculated. Then we can use some trigonometry to turn those normals into UV coordinates and
                sample a texture.
            </p>

            <p class="PageText">
                To do all of this we need to know where the moon is, where the viewer is, which direction our ray will be in for the intersection method,
                the size of the moon&rsquo;s radius, and a texture to sample from. Well, in our skybox, we are always at position <q>float3(0, 0, 0)</q> and the direction of our
                ray is just the <q>normWorldPos</q> we calculated earlier. For now we will just set the moon to be at <q>float3(1, 0, 0)</q>. We will manipulate this position
                later to create an orbit effect. For the radius we will declare a property so that we can control how big the moon looks and for the texture we will also
                declare a property so you can set whatever texture you like. For now, let&rsquo;s just use that
                <a href="https://github.com/FeralPug/FeralPug-Extending-the-Unity-Skybox/blob/main/Textures/TestTexture.jpg" title="link to test texture" target="_blank">test texture</a>
                again.

            </p>

            <p class="PageText">
                To calculate our normals we will use that trigonometry I talked about. We can take the tangent of the normal&rsquo;s X and Z values using the <code>atan2</code>
                function. This will return a value between -&#960; and &#960;. And then to normalize these values we can divide by 2&#960; to get a value between -0.5 and 0.5.
                This will be the X value of our UV coordinates. This range is better than using 0 to 1 because it covers the same range of the texture, but we can use derivatives
                to avoid problems with mip maps. Normally if the UV went from 0 to 1 over the course of 1 pixel the GPU would use the highest mip level possible which would
                cause an ugly seam in our moon. But we can take the <q>frac</q> of our -0.5 to 0.5 value, which will return whatever remainder is after the decimal point of
                what we pass into the function. And this will be equal to our original value but without the derivative problem.
            </p>

            <p class="PageText">
                Then we can take a similar approach for Y coordinate of our UV pair, except this time we will use <code>acos</code> method. It also returns between -&#960; and &#960;.
                At the top of the sphere it will return 0.0 and at the bottom of the sphere it will return &#960;. So, we will use the negative Y value of our spheres normal and then
                divide by &#960; to get a value between 0.0 and 1.0. We don&rsquo;t have to worry about the derivatives here because as we go over the top of the sphere the uv.y value
                will just start to go back towards zero, not jump immediately back to zero. Then we can use this uv coordinate to sample our texture. Add the following code to your
                shader.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl">    [Header (Stars)]
    _StarTex("Star Tex", 2D) = "black" {}
    _StarBending("Star Bending", Range(0, 1)) = 1
    _StarBrightness("Star Brightness", Range(0, 100)) = 8.5

    <span class="addition">[Header(Moon)]
    _MoonTex("Moon Tex", 2D) = "white" {} 
    _MoonRadius ("Moon Radius", Range(0, 1)) = .2</span>

...

    #include "UnityCG.cginc"
    #include "Lighting.cginc"
    <span class="addition">#include "Includes/MoonFunctions.cginc"</span>
    #include "Includes/Scattering.cginc"

...

    uniform sampler2D _StarTex;
    uniform float4 _StarTex_ST;
    uniform float _StarBending, _StarBrightness;

    <span class="addition">uniform sampler2D _MoonTex;
    float4 _MoonTex_ST;
    float _MoonRadius;</span>

    struct appdata

...

    //End of Unity Code

    //Moon
        float3 currentMoonPos = float3(1, 0, 0);
        float radius = _MoonRadius;
        float sphere = SphereIntersect(float3(0, 0, 0), normWorldPos, currentMoonPos, radius);

        //get the position on the sphere and use that to get the normal for the sphere
        float3 moonFragPos = normWorldPos * sphere + float3(0, 0, 0);
        //the normal is how we eventually get uvs and lighting
        float3 moonFragNormal = normalize(moonFragPos - currentMoonPos);

        //get uv from the normal
        float u = atan2(moonFragNormal.z, moonFragNormal.x) / UNITY_TWO_PI;
        //to get around this we take the frac of this u value because these values are the same at the boundary but the frac value doesnt have the seam
        float fracU = frac(u);
                
        //so then we just pick which of the u values we want, the -0.001 just makes it favor the original one
        //to get the y we use acos which returns the same as atan. using acos is better than asin because asin causes warping at the poles
        float2 moonUV = float2(
                        fwidth(u) < fwidth(fracU) - 0.001 ? u : fracU,
                        acos(-moonFragNormal.y) / UNITY_PI
        );   

        //if our sphere tracing returned a positive value we have a moon fragment
        if(sphere >= 0.0){
            //so we grab the moon tex and multiple the color
            float3 moonTex = tex2D(_MoonTex, moonUV).rgb;

            //then lerp to the final color masking out anything under the horizon
            col.rgb = lerp(col.rgb, moonTex, horizonValue);
        }

    //Stars
</code>
</pre>
            </div>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/FirstMoon.png" alt="Image of our test texture moon" />
                <p class="PageImageText"> A rather ominously textured sphere</p>
            </div>

            <p class="PageText">
                Nice! Our moon is correctly textured. One last thing we should do before we move on to adding all the fun features for our moon is to mask out the stars
                where the moon is. The moon should be much closer to us than the stars so any where there is moon, we should not see stars. To do this we can use the value
                of the sphere intersection down where we calculate the final star color. While we&rsquo;re at it lets add a real moon texture from
                <abbr title="National Aeronautics and Space Administration">NASA</abbr> that you can get
                <a href="https://github.com/FeralPug/FeralPug-Extending-the-Unity-Skybox/blob/main/Textures/MoonEquirect.jpg" title="Link to moon texture" target="_blank">here</a>.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl">    stars = pow(stars, _StarBrightness);

    //then lerp to the stars color masking out the horizon
    col.rgb = lerp(col.rgb, col.rgb + stars, night * horizonValue<span class="addition"> * (1 - step(0, sphere))</span>);
    
    return col;
</code>
</pre>
            </div>
            <div class="PageImageContainer">
                <img class="PageImage" src="Media/MoonAndStars.png" alt="Our moon masking out the stars" />
                <p class="PageImageText"> Now we have a textured moon that masks out the stars behind it</p>
            </div>

            <p class="PageText">
                Now that we have our moon the next thing, we will do is get it to orbit around the sky. The way I did this was to use the parametric equation of an ellipse.
                An ellipse has a semi major and minor axis, major being the largest radius on the ellipse and the minor being the smallest radius on the ellipse. The center
                of the ellipse is always the origin or <code>float3(0, 0, 0)</code> just to keep things simple.
            </p>

            <p class="PageText">
                How we get a position from this is to take the cosine of the angle around the ellipse and multiply it by the semi major axis to get the X
                coordinate, and take the sine of the same angle multiplied by the semi minor
                axis to get the Z coordinate. We will only work in 2D for this part so the Y will get set to 0. Then we can normalize this vector to get a direction for
                where our moon is. To get three dimensional orbits we then rotate our position on the ellipse using a rotation matrix that we pass <code>float3</code> with angles to rotate
                around the three world axis.
            </p>

            <p class="PageText">
                To do this we will add three functions, properties for the semi major and minor axis and a property for how fast the moon rotates. One of the functions will
                just apply our rotation matrix, one of the functions will apply the ellipse equation to get our 2D position, and the last function will just call the first
                two so that we do not have to write out three method calls in our shader. Add the following to your <code>MoonFunctions.cginc</code> file just after the include
                guard.
            </p>

            <div class="CodeHighlight">
<pre><code class="language-hlsl line-numbers">#ifndef MOON_INCLUDE
    #define MOON_INCLUDE

    //a rotation matrix to rotate and thing in world space
    float3 RotateWorldPosition(float3 position, float3 axis)
    {
        float3 rot = axis;
        float3x3 rotMat = float3x3(cos(rot.y) * cos(rot.z), -cos(rot.y) * sin(rot.z),
            sin(rot.y), (cos(rot.x) * sin(rot.z)) + (sin(rot.x) * sin(rot.y) * cos(rot.z)),
            (cos(rot.x) * cos(rot.z)) - (sin(rot.x) * sin(rot.y) * sin(rot.z)),
            -sin(rot.x) * cos(rot.y), (sin(rot.x) * sin(rot.z)) - (cos(rot.x) * sin(rot.y) * cos(rot.z)),
            (sin(rot.x) * cos(rot.z)) + (cos(rot.x) * sin(rot.y) * sin(rot.z)), cos(rot.x) * cos(rot.y));
        float3 rotPos = mul(rotMat, position);
        return rotPos;
    }

    //this is using the equation of an ellipse. The angle is time * speed, or what ever angle you want to sample at
    float3 ElipsePosition(float2 MajMinAxis, float angle)
    {
        float3 orbitPos;
        orbitPos.x = (MajMinAxis.x * cos(angle));
        orbitPos.y = 0;
        orbitPos.z = (MajMinAxis.y * sin(angle));
        return normalize(orbitPos);
    }

    //this just calls the above function and rotates it by the desired amount
    float3 GetOrbitPosition(float3 orbitOffsetAngles, float2 MajMinAxis, float angle)
    {
        float3 p = ElipsePosition(MajMinAxis, angle);
        p = RotateWorldPosition(p, float3(radians(orbitOffsetAngles.x), radians(orbitOffsetAngles.y), radians(orbitOffsetAngles.z)));
        return p;
    }</code>
</pre>
            </div>

            <p class="PageText">
                Then also add the properties to our shader, declare them and call the functions in the frag function. For the angle we will just multiply <code>_Time.y</code>
                by our orbit speed property. Make the following additions to the shader.
            </p>

            <div class="CodeHighlight">
<pre><code class="language-hlsl">[Header(Moon)]
    _MoonTex("Moon Tex", 2D) = "white" {}
    _MoonRadius ("Moon Radius", Range(0, 1)) = .2
    <span class="addition">_MoonOrbitAngle("Moon Orbit Start Angle (XYZ)", vector) = (0, 0, 45, 0)
    _MoonOrbitSpeed("Moon Orbit Speed", Range(-1, 1)) = .05
    _MoonSemiMajAxis("Moon Semi Major Axis", float) = 1
    _MoonSemiMinAxis("Moon Semi Minor Axis", float) = 1</span>

...

    uniform sampler2D _MoonTex;
    uniform float4 _MoonTex_ST;
    <span class="addition">uniform float4 _MoonOrbitAngle;</span>
    uniform float _MoonRadius;
    <span class="addition">uniform float _MoonOrbitSpeed, _MoonSemiMajAxis, _MoonSemiMinAxis;</span>

...

    //Moon
        <span class="deletion"><span class="addition">float3 currentMoonPos = float3(1, 0, 0);</span></span>

        <span class="addition">float orbitAngle = _Time.y * _MoonOrbitSpeed;
            
        //we also need to grab the half radius of the ellipse at the major and minor Axis
        //these are used in the ellipse equation.
        float2 MajMinAxis = float2(_MoonSemiMajAxis, _MoonSemiMinAxis);

        //this equation takes these values along with the _MoonOrbitAngle to figure out the position in the moons orbit
        float3 currentMoonPos = GetOrbitPosition(_MoonOrbitAngle, MajMinAxis, orbitAngle);</span>  

        float radius = _MoonRadius;
        float sphere = SphereIntersect(float3(0, 0, 0), normWorldPos, currentMoonPos, radius);

</code>
</pre>
            </div>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/OrbitMoon.gif" alt="Moon in orbit" />
                <p class="PageImageText"> It&rsquo;s alive!!!</p>
            </div>

            <p class="PageText">
                Play with the axis values as you like, they will change how fast the moon appears to fly by. But to really get the effect of eccentric orbits the moon
                needs to change size as it gets further away. To do this we will change our <code>_MoonRadius</code> property to a <code>_MoonMaxSize</code> and
                <code>_MoonMinSize</code>. Then we will calculate how close the moon is to the semi minor axis and use that value to <code>lerp</code> between these
                two sizes. It isn&rsquo;t physically accurate but it works well and gives us more control over how the moon will look. First, we will add the
                <code>lerp</code> function to our <code>MoonFunctions.cginc</code> file just after the <code>GetOrbitPosition</code> function.
            </p>

<div class="CodeHighlight">
<pre><code class="language-hlsl">   float3 GetOrbitPosition(float3 orbitOffsetAngles, float2 MajMinAxis, float angle)
    {
        float3 p = ElipsePosition(MajMinAxis, angle);
        p = RotateWorldPosition(p, float3(radians(orbitOffsetAngles.x), radians(orbitOffsetAngles.y), radians(orbitOffsetAngles.z)));
        return p;
    }

    <span class="addition">//this lerps between two radius values based on how close the moon is to either the major or minor axis, major in this case is always (1, 0, 0)
    float GetMoonDistance(float Min, float Max, float2 MajMinAxis, float angle)
    {
        float3 pos = ElipsePosition(MajMinAxis, angle);
        float lerpFactor = abs(dot(pos, float3(0, 0, 1)));
        float dist = lerp(Min, Max, smoothstep(0, 1, lerpFactor));
        return dist;
    }</span></code>
</pre>
</div>

            <p class="PageText">
                All this function is doing is calling the <code>EllipsePosition</code> function again with the same values as before but this time we do not rotate the position.
                That way we can use the dot product of that position and forward, which by default is always the direction of the semi minor axis, and then use that value to 
                lerp between the min and max sizes. I use a <code>smoothstep</code> function here to just make the change a little bit smoother.
            </p>

            <p class="PageText">
                Now we can call this function in our shader to get the radius for our moon at any point during its orbit. We just have to add a few new properties, declare them
                and then call the new function and assign its return value to our radius variable. Make the following changes.
            </p>

<div class="CodeHighlight">
<pre><code class="language-hlsl">   [Header(Moon)]
    _MoonTex("Moon Tex", 2D) = "white" {}
    <span class="deletion"><span class="addition">_MoonRadius ("Moon Radius", Range(0, 1)) = .2</span></span>
    <span class="addition">_MoonMaxSize ("Moon Max Size", Range(0, 1)) = .2
    _MoonMinSize ("Moon Min Size", Range(0, 1)) = .2</span>
    _MoonOrbitAngle("Moon Orbit Start Angle (XYZ)", vector) = (0, 0, 45, 0)
    _MoonOrbitSpeed("Moon Orbit Speed", Range(-1, 1)) = .05
    _MoonSemiMajAxis("Moon Semi Major Axis", float) = 1
    _MoonSemiMinAxis("Moon Semi Minor Axis", float) = 1

...

    uniform sampler2D _MoonTex;
    uniform float4 _MoonTex_ST;
    uniform float4 _MoonOrbitAngle;
    <span class="deletion"><span class="addition">uniform float _MoonRadius;</span></span>
    <span class="addition">uniform float _MoonMaxSize, _MoonMinSize;</span>
    uniform float _MoonOrbitSpeed, _MoonSemiMajAxis, _MoonSemiMinAxis;

...

    float3 currentMoonPos = GetOrbitPosition(_MoonOrbitAngle, MajMinAxis, orbitAngle);    

    <span class="deletion"><span class=" addition">float radius = _MoonRadius;</span></span>
    <span class=" addition">float radius = GetMoonDistance(_MoonMinSize, _MoonMaxSize, MajMinAxis, orbitAngle);</span>
    float sphere = SphereIntersect(float3(0, 0, 0), normWorldPos, currentMoonPos, radius);</code>
</pre>
</div>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/BigMoon.gif" alt="Moon getting bigger" />
                <p class="PageImageText"> Bigger than before!</p>
            </div>

            <p class="PageText">
                Now the only problem with this method is that currently the moon will always be smallest at its starting position and largest 90 degrees away from that
                position. That is kind of annoying. So what we can do is we can rotate our moon around its orbit before calculating the radius, and then not tell the 
                <code>GetMoonDistance</code> function about that. This will offset where the moon gets bigger and smaller, giving us full control over its orbit.
            </p>

            <p class="PageText">
                To get this working takes a little bit of doing. We need to rotate the moon around the axis that is equal to the normal of the plane that the ellipse lies in.
                To calculate this we can find the position of the moon at a different angle from it&rsquo;s current position and take the cross product of those two vectors. Then
                once we have that up vector, we can use another rotation matrix to rotate however much we want to offset the position by. We cannot use the same rotation matrix
                that we used before, because that rotates in world space, but we can use a matrix that rotates around an arbitrary axis. You can read more about how to calculate
                this matrix <a href="https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle" title="Link to Wiki page" target="_blank">here</a>.
            </p>

            <p class="PageText">
                So once again we will add one more function to our <code>MoonFunctions.cginc</code> inlude file. This function will rotate a point around an arbitrary axis
                as was just described. Then we will add a property to our shader to allow control over how much the moon is rotated, and declare that property. To get the up we
                will just call the <code>GetOrbitPosition</code> method but pass in <code>orbitAngle - 1</code> instead of just <code>orbitAngle</code> and take the cross product
                of those two results. Then we can pass the up vector along with the amount to rotate, and we will have complete control over our moon&rsquo;s orbit. Make the 
                following changes.
            </p>

<div class="CodeHighlight">
<pre><code class="language-hlsl">#ifndef MOON_INCLUDE
    #define MOON_INCLUDE    

...
    
    //sphere tracing from https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
    float SphereIntersect(float3 rayOrigin, float3 rayDirection, float3 spherePos, float sphereRadius)
    {
        float3 originToCenter = rayOrigin - spherePos;
        float b = dot(originToCenter, rayDirection);
        float c = dot(originToCenter, originToCenter) - sphereRadius * sphereRadius;
        float h = b * b - c;
        if (h < 0.0)
        {
            return -1.0;
        }
        h = sqrt(h);
        return -b - h;
    }

    <span class="addition">// How to rotate around any axis https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
    float3 RotateArbitraryAxis(float3 vec, float angle, float3 axis)
    {
        float rads = radians(angle);
        float3x3 rot = float3x3(float3(cos(rads) + dot(axis.x, axis.x) * (1 - cos(rads)), axis.x * axis.y * (1 - cos(rads)) - axis.z * sin(rads), axis.x * axis.z * (1 - cos(rads)) + axis.y * sin(rads)),
            float3(axis.y * axis.x * (1 - cos(rads)) + axis.z * sin(rads), cos(rads) + dot(axis.y, axis.y) * (1 - cos(rads)), axis.y * axis.z * (1 - cos(rads)) - axis.x * sin(rads)),
            float3(axis.z * axis.x * (1 - cos(rads)) - axis.y * sin(rads), axis.z * axis.y * (1 - cos(rads)) + axis.x * sin(rads), cos(rads) + dot(axis.z, axis.z) * (1 - cos(rads))));

        return mul(rot, vec);
    }</span>

#endif
    </code>
</pre>

    <p class="PageImageText">Adding the arbitrary rotation matrix to our <code>MoonFunctions.cginc</code> file</p>
</div>



<div class="CodeHighlight">
<pre><code class="language-hlsl">   [Header(Moon)]
    _MoonTex("Moon Tex", 2D) = "white" {} 
    _MoonMaxSize ("Moon Max Size", Range(0, 1)) = .2
    _MoonMinSize ("Moon Min Size", Range(0, 1)) = .2 
    _MoonOrbitAngle("Moon Orbit Start Angle (XYZ)", vector) = (0, 0, 45, 0)
    <span class="addition">_MoonOrbitOffset("Moon Orbit Offset", Range(0, 90)) = 0</span>
    _MoonOrbitSpeed("Moon Orbit Speed", Range(-1, 1)) = .05
    _MoonSemiMajAxis("Moon Semi Major Axis", float) = 1
    _MoonSemiMinAxis("Moon Semi Minor Axis", float) = 1
    
...

    uniform sampler2D _MoonTex;
    uniform float4 _MoonTex_ST;
    uniform float4 _MoonOrbitAngle;
    uniform float _MoonMaxSize, _MoonMinSize;
    uniform float _MoonOrbitSpeed, <span class="addition">_MoonOrbitOffset,</span> _MoonSemiMajAxis, _MoonSemiMinAxis;

...

    //this equation takes these values along with the _MoonOrbitAngle to figure out the position in the moons orbit
    float3 currentMoonPos = GetOrbitPosition(_MoonOrbitAngle, MajMinAxis, orbitAngle);    

    <span class="addition">//we need to know which direction is up from the orbit plane, We do this by getting a different position and crossing the two positions
    float3 prevMoonPos = GetOrbitPosition(_MoonOrbitAngle, MajMinAxis, orbitAngle - 1);  
    float3 moonUp = normalize(cross(currentMoonPos, prevMoonPos)); 

    //Then we can offset the position around the orbit. This allows us to change where in the orbit the planet should be largest or smallest         
    currentMoonPos = RotateArbitraryAxis(currentMoonPos, _MoonOrbitOffset, moonUp);</span>

    //float radius = _MoonRadius;
    float radius = GetMoonDistance(_MoonMinSize, _MoonMaxSize, MajMinAxis, orbitAngle);
    float sphere = SphereIntersect(float3(0, 0, 0), normWorldPos, currentMoonPos, radius);
    </code>
</pre>

    <p class="PageImageText">Changes made to the shader</p>
</div>

            <div class="PageImageContainer">
                    <img class="PageImage" src="Media/BigMoonInSky.gif" alt="Gif of the moon getting bigger in the sky" />
                    <p class="PageImageText"> Now our moon can get closer while high in the sky. I have set the semi major axis to 4, the minor to 1,
                <code>_MoonOrbitAngle</code> to <code>float3(0, 0, 45)</code> and the <code>_MoonOrbitOffset</code> to 90.</p>
            </div>

            <p class="PageText">
                Great, that gives us complete control over our moon&rsquo;s orbit. Now the last features we will add to our moon is phases and spinning. For phases we will have 
                two modes: user-controller or light-controlled. For our spin we will have three modes: tidal-locked, local-rotation, and the default, which is world rotation.
                We will start with the spin as that is a little more complicated.
            </p>

            <p class="PageText">
                To spin our moon, we will declare a vector property that will be the angle per second we want our moon to rotate. We will pass that into our <code>RotateWorldPosition</code>
                function defined in our <code>MoonFunctions.cginc</code> along with the normal, after converting the angle to radians, as that is what the function expects.
                This will rotate the normal around the moon origin, and since we use the normal to calculate uvs, that will spin the moon. That is pretty much all we need to
                do to rotate the moon. However, for our different modes we will define the local, or object space, coordinates of our moon and create a matrix that converts from world space
                to local space using that local definition. The axis of our local space will be z = towards the camera, x = opposite the direction of orbit, and y = the <code>moonUp</code>
                variable that we already calculated.
            </p>

            <p class="PageText">
                Then with this matrix we can convert the normal to local space and rotate the normal if we are spinning locally, or just use the local normal if in tidal-lock 
                mode. This works because in local space the normals that are visible to the player are always the same. However, to make any part of the moon texture visible,
                we will rotate the local normal by the same amount so that the user can control which part of the moon faces the player. To do this we will declare a few
                properties that control the spin of the moon and what mode the shader is in. We will use the enum property attribute to control keywords that are defined for our
                shader. You can read more about that <a href="https://docs.unity3d.com/ScriptReference/MaterialPropertyDrawer.html" title="Link to Unity docs page" target="_blank">here</a>.
                Add the following code to your shader.
            </p>

<div class="CodeHighlight">
<pre>
<code class="language-hlsl">
    [Header(Moon)]
    _MoonTex("Moon Tex", 2D) = "white" {} 
    _MoonMaxSize ("Moon Max Size", Range(0, 1)) = .2
    _MoonMinSize ("Moon Min Size", Range(0, 1)) = .2 
    _MoonOrbitAngle("Moon Orbit Start Angle (XYZ)", vector) = (0, 0, 45, 0)
    _MoonOrbitOffset("Moon Orbit Offset", Range(0, 90)) = 0
    _MoonOrbitSpeed("Moon Orbit Speed", Range(-1, 1)) = .05
    _MoonSemiMajAxis("Moon Semi Major Axis", float) = 1
    _MoonSemiMinAxis("Moon Semi Minor Axis", float) = 1
    <span class="addition">[KeywordEnum(TIDAL_LOCK, LOCAL_ROTATE, WORLD_ROTATE)] _MoonSpinOption ("Moon Spin Option", float) = 1
    _MoonTidalAngle("Moon Tidal Lock Angle (XYZ)", vector) = (0, 0, 0, 0)
    _MoonSpinSpeed("Moon Spin Speed (XYZ)", vector) = (0, 0, 0, 0)</span>

...

    uniform sampler2D _MoonTex;
    uniform float4 _MoonTex_ST;
    uniform float4 _MoonOrbitAngle;
    uniform float _MoonMaxSize, _MoonMinSize;
    uniform float _MoonOrbitSpeed, _MoonOrbitOffset, _MoonSemiMajAxis, _MoonSemiMinAxis;
    <span class="addition">uniform float3 _MoonSpinSpeed, _MoonTidalAngle;</span>

...

    //get the position on the sphere and use that to get the normal for the sphere
    float3 moonFragPos = normWorldPos * sphere + float3(0, 0, 0);
    //the normal is how we eventually get uvs and lighting
    float3 moonFragNormal = normalize(moonFragPos - currentMoonPos);

    <span class="addition">//get the local forward and tangent vector for the sphere based on the up
    float3 moonForward = normalize(-currentMoonPos);
    float3 moonTangent = cross(moonForward, moonUp);

    //construct a world to object matrix
    float3x3 worldToObject = float3x3(moonTangent, moonUp, moonForward);   

//if we want tidal locking, i.e. the same face always looks at the viewer
#ifdef _MOONSPINOPTION_TIDAL_LOCK     
                moonFragNormal = mul(worldToObject, moonFragNormal);
                //rotate the normal to change which side of the moon points towards the viewer
                moonFragNormal = RotateWorldPosition(moonFragNormal, float3(radians(_MoonTidalAngle.x), radians(_MoonTidalAngle.y), radians(_MoonTidalAngle.z)));
//if not tidal locked then we can have the planet spin
#else
    //we can do this in local coords
    #ifdef _MOONSPINOPTION_LOCAL_ROTATE
                moonFragNormal = mul(worldToObject, moonFragNormal);
                float3 spinAngle = _Time.y * _MoonSpinSpeed.xyz;
                moonFragNormal = RotateWorldPosition(moonFragNormal, float3(radians(spinAngle.x), radians(spinAngle.y), radians(spinAngle.z)));
                moonFragNormal = mul(moonFragNormal, worldToObject);
    //or in world coords
    #else
                float3 spinAngle = _Time.y * _MoonSpinSpeed.xyz;
                moonFragNormal = RotateWorldPosition(moonFragNormal, float3(radians(spinAngle.x), radians(spinAngle.y), radians(spinAngle.z)));
    #endif
#endif</span>

    //get uv from the normal
    float u = atan2(moonFragNormal.z, moonFragNormal.x) / UNITY_TWO_PI;
    //to get around this we take the frac of this u value because these values are the same at the boundary but the frac value doesnt have the seam
    float fracU = frac(u);
                
    //so then we just pick which of the u values we want, the -0.001 just makes it favor the original one
    //to get the y we use acos which returns the same as atan. using acos is better than asin because asin causes warping at the poles
    float2 moonUV = float2(
                    fwidth(u) < fwidth(fracU) - 0.001 ? u : fracU,
                    acos(-moonFragNormal.y) / UNITY_PI
    );   
</code>
</pre>
</div>

            <div class="PageImageContainer">
                    <img class="PageImage" src="Media/RotateWorld.gif" alt="Gif of the moon spinning" />
                    <p class="PageImageText"> Our moon spinning in world space</p>
            </div>

            <div class="PageImageContainer">
                    <img class="PageImage" src="Media/TidalLock.gif" alt="Gif of the moon tidal locked" />
                    <p class="PageImageText"> Our moon tidal locked always showing the same face</p>
            </div>

            <p class="PageText">
                Lastly, we will add phases to our moon to finish off this part of the shader. To have the phases be based off of the sun direction all we have to do is take the
                dot product of the moon normal and the light direction, to simulate basic Lambert lighting. To have user control over the moon phase is a little bit more
                complicated. To do this we will convert our normal to local space, and take the dot product with <code>float3(0, 0, 1)</code>, or forward, which is always
                towards the player in local space. We can then rotate this forward with a vector property that we declare to change its direction. Then finally we can take the
                dot product of this vector and the normal in local space to simulate Lambert lighting. Then with this dot product we will <code>lerp</code> between the 
                moon and the sky color. We will make a few changes to what we just did because we do not need to
                convert to local space multiple times. We will also add a property to control the color of the moon while we are finishing up. Add the following.
            </p>

<div class="CodeHighlight">
<pre>
<code class="language-hlsl">
        [Header(Moon)]
        <span class="addition">_MoonColor("Moon Color", Color) = (1, 1, 1, 1)</span>
        _MoonTex("Moon Tex", 2D) = "white" {} 
        _MoonMaxSize ("Moon Max Size", Range(0, 1)) = .2
        _MoonMinSize ("Moon Min Size", Range(0, 1)) = .2 
        _MoonOrbitAngle("Moon Orbit Start Angle (XYZ)", vector) = (0, 0, 45, 0)
        _MoonOrbitOffset("Moon Orbit Offset", Range(0, 90)) = 0
        _MoonOrbitSpeed("Moon Orbit Speed", Range(-1, 1)) = .05
        _MoonSemiMajAxis("Moon Semi Major Axis", float) = 1
        _MoonSemiMinAxis("Moon Semi Minor Axis", float) = 1
        <span class="addition">[Toggle(PHASE_LIGHT)] _MoonPhaseOption ("Auto Phase", float) = 1
        _MoonPhase("Moon Phase", vector) = (50, 0, 0, 0)</span>
        [KeywordEnum(TIDAL_LOCK, LOCAL_ROTATE, WORLD_ROTATE)] _MoonSpinOption ("Moon Spin Option", float) = 1
        _MoonTidalAngle("Moon Tidal Lock Angle (XYZ)", vector) = (0, 0, 0, 0)
        _MoonSpinSpeed("Moon Spin Speed (XYZ)", vector) = (0, 0, 0, 0)

...

    #pragma multi_compile _MOONSPINOPTION_TIDAL_LOCK _MOONSPINOPTION_LOCAL_ROTATE _MOONSPINOPTION_WORLD_ROTATE
    <code class="addition">multi_compile _ PHASE_LIGHT</code>
    #pragma multi_compile_local _SUNDISK_NONE _SUNDISK_SIMPLE _SUNDISK_HIGH_QUALITY

...

    uniform sampler2D _MoonTex;
    uniform float4 _MoonTex_ST;
    <span class="addition">uniform float4 _MoonColor;</span>
    uniform float4 _MoonOrbitAngle;
    uniform float _MoonMaxSize, _MoonMinSize;
    uniform float _MoonOrbitSpeed, _MoonOrbitOffset, _MoonSemiMajAxis, _MoonSemiMinAxis;
    uniform float3 _MoonSpinSpeed, _MoonTidalAngle;
    <span class="addition">uniform float3 _MoonPhase;</span>

    //construct a world to object matrix
    float3x3 worldToObject = float3x3(moonTangent, moonUp, moonForward);   

    <span class="addition">//transform the normal into local space and use that to calculate lighting
    //it looks wrong to have the lighting change as it goes across the sky, that why we keep it static
    float3 phaseNormal = mul(worldToObject, moonFragNormal);

#ifndef PHASE_LIGHT
    //rotate the normal by the desired amount to change the phase of the moon
    float3 moonPhase = RotateWorldPosition(float3(0, 0, 1), float3(radians(_MoonPhase.x), radians(_MoonPhase.y), radians(_MoonPhase.z)));

    //basic lambert lighting
    float NDotL = dot(moonPhase, phaseNormal);

#else
    //basic lambert lighting
    float NDotL = dot(sunPos, moonFragNormal);

#endif</span>

//if we want tidal locking, i.e. the same face always looks at the viewer
#ifdef _MOONSPINOPTION_TIDAL_LOCK         
    //we use the local definiton of the normal
    <span class="deletion"><span class="addition">moonFragNormal = mul(worldToObject, moonFragNormal);</span></span>
    <span class="addition">moonFragNormal = phaseNormal;</span>
    //and rotate the normal to change which side of the moon points towards the viewer
    moonFragNormal = RotateWorldPosition(moonFragNormal, float3(radians(_MoonTidalAngle.x), radians(_MoonTidalAngle.y), radians(_MoonTidalAngle.z)));
//if not tidal locked then we can have the planet spin
#else
    //we can do this in local coords
    #ifdef _MOONSPINOPTION_LOCAL_ROTATE
        //we use the local definiton of the normal
        <span class="deletion"><span class="addition">moonFragNormal = mul(worldToObject, moonFragNormal);</span></span>
        <span class="addition">moonFragNormal = phaseNormal;</span>
        float3 spinAngle = _Time.y * _MoonSpinSpeed.xyz;
        moonFragNormal = RotateWorldPosition(moonFragNormal, float3(radians(spinAngle.x), radians(spinAngle.y), radians(spinAngle.z)));
        moonFragNormal = mul(moonFragNormal, worldToObject);
    //or in world coords
    #else
        float3 spinAngle = _Time.y * _MoonSpinSpeed.xyz;
        moonFragNormal = RotateWorldPosition(moonFragNormal, float3(radians(spinAngle.x), radians(spinAngle.y), radians(spinAngle.z)));
    #endif
#endif

    //get uv from the normal
    float u = atan2(moonFragNormal.z, moonFragNormal.x) / UNITY_TWO_PI;
    //to get around this we take the frac of this u value because these values are the same at the boundary but the frac value doesnt have the seam
    float fracU = frac(u);
                
    //so then we just pick which of the u values we want, the -0.001 just makes it favor the original one
    //to get the y we use acos which returns the same as atan. using acos is better than asin because asin causes warping at the poles
    float2 moonUV = float2(
                    fwidth(u) < fwidth(fracU) - 0.001 ? u : fracU,
                    acos(-moonFragNormal.y) / UNITY_PI
    );   

    //if our sphere tracing returned a positive value we have a moon fragment
    if(sphere >= 0.0){
        //so we grab the moon tex and multiple the color
        float3 moonTex = tex2D(_MoonTex, moonUV).rgb <span class="addition">* _MoonColor.rgb;

        //then we lerp to the color be how much of the moon is lit
        moonTex = lerp(col.rgb, moonTex * NDotL, saturate(NDotL));</span>

        //then lerp to the final color masking out anything uner the horizon and anywhere there is clouds as they should be infron of the moon
        col.rgb = lerp(col.rgb, moonTex, horizonValue);
    }
</code>
</pre>
</div>

            <div class="PageImageContainer">
                    <img class="PageImage" src="Media/MoonPhase.png" alt="Our moon with phases" />
                    <p class="PageImageText"> Now we have phases of our moon</p>
                </div>

            <p class="PageText">
                And with that we have completed the moon part of our shader. Our moon can orbit, rotate, and have different phases, and it is all user controlled. You can
                get the shader finished up to this point 
                <a href="https://github.com/FeralPug/FeralPug-Extending-the-Unity-Skybox/tree/main/Part%204:%20Moon" title="Link to finished section" target="_blank">here</a> and
                you can find the textures used <a href="https://github.com/FeralPug/FeralPug-Extending-the-Unity-Skybox/tree/main/Textures" title="Link to finished section" target="_blank">here</a>.
                Next we will wrap up by adding some clouds to our sky box.
            </p>

            <h2 class="Section" id="Part5">Part 5: Clouds</h2>

            <p class="PageText">
                The clouds for our shader will be generated from a noise texture. The look of your clouds will largely depend on the texture you use. I made mine in Gimp.
                My process was to start with a blank square image. Then go to <strong>Filters > Render > Noise > Solid Noise</strong>. In the settings check tileable and 
                turbulent. Then turn the detail way up, I set mine to 10. Then mess with the scale and seed until you are happy. Then go over to <strong>Colors > 
                Brightness-Contrast</strong> and play with the contrast setting to your liking. I did this to create more space between the bright areas in the texture,
                 which leads to space between the clouds in our sky. I ended up with this, but experimentation here will yield different results.
            </p>

            <div class="PageImageContainer">
                    <img class="PageImage" src="Media/cloudDiffuse.png" alt="Our cloud texture" />
                    <p class="PageImageText"> Cloud noise texture used for our skybox.</p>
            </div>

            <p class="PageText">
                To add some extra detail to our clouds we will also sample a normal map and do some basic faux lighting. To do this we will use another noise texture. Make a
                second noise texture but use different settings so we get different details than our first texture. Then in Unity, change the import settings to normal map, check
                the <strong>Create from Grayscale</strong> and adjust the bumpiness to your liking, I set mine to 0.15. Here is the texture I used for the normal map.
            </p>

            <div class="PageImageContainer">
                    <img class="PageImage" src="Media/cloudBump.png" alt="Our cloud normal texture" />
                    <p class="PageImageText"> Cloud noise texture used for our cloud&rsquo;s normals.</p>
            </div>

            <p class="PageText">
                Now we can get to the actual cloud code. What we will do is sample our cloud texture twice but at different points and scale. We will do this for the normals
                and the regular textures. To get uvs we will use the same method we did for our stars but with a separate <code>_CloudBending</code> property so that they can be
                independent. To sample the textures at different points we will add some properties to control how the textures are scaled and translated over time and we will
                add a property to control what direction they translate in. A lot of this could be adjusted to fit whatever particular effect you want to generate. Then once
                we have our texture samples we will blend them
            </p>

            <p class="PageText">
                To blend these texture samples we will use some remapping of values, subtraction, and a smoothstep for our diffuse textures, and we will use Unity&rsquo;s White out
                blending function <code>BlendNormals</code>.
                The idea behind the remapping is that our texture values range from 0 to 1. So, we can darken our final result by subtracting the second sample from our first
                sample. But by remapping the value to be between two user-controlled values we can control how much our final result is affected by this blending. Then we will
                <code>smoothstep</code> the result of this blending between two more user-controlled values to brighten the final result. So, to get started, add the following code
                to our shader. We are adding a lot of properties to allow a lot of control over how the textures are sampled and then ultimately blended together.
            </p>

<div class="CodeHighlight">
<pre>
<code class="language-hlsl">    <span class="addition">_SkyFadeStart("Sky Fade Start", Range(-1, 1)) = .05
    SkyFadeEnd("Sky End Start", Range(-1, 1)) = -.05</span>

    [Header(Clouds)]
    _CloudDiffuse("Cloud Diffuse", 2D) = "black" {}
    [NoScaleOffset]_CloudNormal("Cloud Normal", 2D) = "bump" {}
    _CloudAlphaCutoff("Cloud Alpha Thresh", Range(0, 1)) = 0.2
    _CloudAlphaMax("Cloud Alpha Max", Range(0, 1)) = .5
    _CloudNormalSpeed("Cloud Normal Speed", Range(0, 1)) = .1
    _CloudSpeed("Cloud Speed", float) = .001
    _CloudDirection("Cloud Direction", float) = 0
    _CloudBending("Cloud Bending", Range(0, 1)) = .25
    _CloudBlendSpeed("Cloud Blend Speed", float) = -.02
    _CloudBlendScale("Cloud Blend Scale", float) = 1
    _CloudBlendLB("Cloud Blend LB", Range(0, 1)) = .17
    _CloudBlendUB("Cloud Blend UB", Range(0, 1)) = .32

...

    <span class="addition">uniform half _SkyFadeStart, _SkyFadeEnd;</span>

    uniform sampler2D _CloudDiffuse, _CloudNormal;
    uniform float4 _CloudDiffuse_ST, _CloudNormal_ST;
    uniform float _CloudSpeed, _CloudBlendSpeed;
    uniform float _CloudNormalScale;
    uniform float _CloudAlphaMax, _CloudAlphaCutoff;
    uniform float _CloudBending;
    uniform float _CloudDirection, _CloudBlendScale, _CloudBlendLB, _CloudBlendUB, _CloudNormalSpeed;

...

        <span class="addition">#if defined(UNITY_COLORSPACE_GAMMA) && !SKYBOX_COLOR_IN_TARGET_COLOR_SPACE
            col.rgb = LINEAR_2_OUTPUT(col);
        #endif

    //End of Unity Code</span>

    //Clouds             
        //by dividing the xz by the y we can project the coordinate onto a flat plane, the bending value transitions it from a plane to a sphere
        float2 cloudUV = normWorldPos.xz / (normWorldPos.y + _CloudBending);

        //this is just a simple way to rotate the direction the clouds will travel in
        float2 cloudDir = float2(1, 0);
        cloudDir.x = cloudDir.x * cos(radians(_CloudDirection));
        cloudDir.y = cloudDir.y * sin(radians(_CloudDirection));

        //sample the cloud texture twice at different speeds, offsets and scale, the float2 here just makes so they dont ever line up exactly
        float cloud1 = tex2D(_CloudDiffuse, cloudUV * _CloudDiffuse_ST.xy + _CloudDiffuse_ST.zw + _Time.y * _CloudSpeed * cloudDir).x * horizonValue;
        float cloud2 = tex2D(_CloudDiffuse, cloudUV * _CloudDiffuse_ST.xy * _CloudBlendScale + _CloudDiffuse_ST.zw - _Time.y * _CloudBlendSpeed * cloudDir + float2(.373, .47)).x * horizonValue;
        
        //we remap the clouds to be between our two values. This allows us to have control over the blending
        cloud2 = Remap(cloud2, float2(0, 1), float2(_CloudBlendLB, _CloudBlendUB));

        //subtract cloud2 from cloud1, this is how we blend them. We could also mulitple them but I like the result of this better
        float clouds = cloud1 - cloud2;

        //then we smoothstep the clouds at desired values, this allows us control the brightness and the edge of the clouds
        clouds = smoothstep(_CloudAlphaCutoff, _CloudAlphaMax, clouds);

        //do the same thing except we slow the speed because it can look wierd if moving to fast
        float3 cloudNormal1 = UnpackNormal(tex2D(_CloudNormal, cloudUV * _CloudDiffuse_ST.xy + _CloudDiffuse_ST.zw + _Time.y * _CloudSpeed * cloudDir));
        float3 cloudNormal2 = UnpackNormal(tex2D(_CloudNormal, cloudUV * _CloudDiffuse_ST.xy * _CloudBlendScale + _CloudDiffuse_ST.zw - _Time.y * _CloudBlendSpeed * _CloudNormalSpeed * cloudDir + float2(.373, .47)));

        //blend normals
        float3 cloudNormal = BlendNormals(cloudNormal1, cloudNormal2);

    <span class="addition">//Moon
        float orbitAngle = _Time.y * _MoonOrbitSpeed;</span>
</code>
</pre>

    <p class="PageImageText">
                    Highlighted code here is code that was already in the shader. Included to provide a reference to where the code goes.
                </p>
</div>

            <p class="PageText">
                The idea behind the blending of our diffuse textures is that our texture values range from 0 to 1. So, we can darken our final result by subtracting the second sample from our first 
                sample. But by remapping the value to be between two user-controlled values we can control how much our final result is affected by this blending. Then we will
                <code>smoothstep</code> the result of this blending between two more user-controlled values to brighten the final result. It isn&rsquo;t any technical process,
                it is more that it produces a result that I was happy with.
            </p>

            <p class="PageText">
                Now we need to include this in the final color of the pixel. I mentioned using faux lighting because we will just use the dot product of our cloud normal
                and an up vector to create lighting. I like this because then when the sun is set the light position does not affect the cloud color, but you could change it
                to use the light position or transition between either method. 
            </p>

            <p class="PageText">
                We will also add day and night color properties that we will <code>lerp</code> between based off of the <code>night</code> value that we calculate earlier in the
                fragment function. Then we can calculate the final color value by multiplying the faux lighting value by the color. Before this multiplication I did one more 
                remap on the lighting value to allow control over how much the lighting affects the color. I also added one more line where we divide our color by a user-controlled
                value that is in between 0 and 1 to provide a bit of a final brightness control to the cloud color. Then all we have to do is <code>lerp</code> between the <code>col</code>
                value and our cloud color by our cloud value calculated from the textures.
            </p>

<div class="CodeHighlight">
<pre>
<code class="language-hlsl">    [Header(Clouds)]
    _CloudDiffuse("Cloud Diffuse", 2D) = "black" {}
    [NoScaleOffset]_CloudNormal("Cloud Normal", 2D) = "bump" {}
    <span class="addition">_CloudColor("Cloud Color", Color) = (1, 1, 1, 1)
    _CloudNightColor("Cloud Night Color", COLOR) = (.34, .34, .34, 1)</span>
    _CloudAlphaCutoff("Cloud Alpha Thresh", Range(0, 1)) = 0.2
    _CloudAlphaMax("Cloud Alpha Max", Range(0, 1)) = .5
    <span class="addition">_CloudColorBoost("Cloud Color Boost", Range(0, 1)) = 0
    _CloudNormalEffect("Cloud Normal Effect", Range(0, 1)) = .37</span>
    _CloudNormalSpeed("Cloud Normal Speed", Range(0, 1)) = .1
    _CloudSpeed("Cloud Speed", float) = .001
    _CloudDirection("Cloud Direction", float) = 0
    _CloudBending("Cloud Bending", Range(0, 1)) = .25
    _CloudBlendSpeed("Cloud Blend Speed", float) = -.02
    _CloudBlendScale("Cloud Blend Scale", float) = 1
    _CloudBlendLB("Cloud Blend LB", Range(0, 1)) = .17
    _CloudBlendUB("Cloud Blend UB", Range(0, 1)) = .32

...

    uniform sampler2D _CloudDiffuse, _CloudNormal;
    uniform float4 _CloudDiffuse_ST, _CloudNormal_ST;
    uniform float _CloudSpeed, <span class="addition">_CloudColorBoost</span>, _CloudBlendSpeed;
    <span class="addition">uniform float3 _CloudColor, _CloudNightColor;</span>
    uniform float _CloudNormalScale, <span class="addition">_CloudNormalEffect</span>;
    uniform float _CloudAlphaMax, _CloudAlphaCutoff;
    uniform float _CloudBending;
    uniform float _CloudDirection, _CloudBlendScale, _CloudBlendLB, _CloudBlendUB, _CloudNormalSpeed;

...

    //blend normals
    float3 cloudNormal = BlendNormals(cloudNormal1, cloudNormal2);

    <span class="addition">//we blend the normal with the up vector. This dot product with up gives the final color the effect the clouds are fluffy
    float NdotUp = dot(cloudNormal, float3(0, 1, 0));

    //adjust the color for night
    float3 cloudColor = lerp(_CloudColor, _CloudNightColor, night);

    //then remap the dot product to be between our desired value, this reduces the effect of the normal
    cloudColor = cloudColor * Remap(NdotUp, float2(-1, 1), float2(1 -_CloudNormalEffect, 1));
            
    //then divide by the color boost to brighten the clouds
    cloudColor = saturate(cloudColor / (1 - _CloudColorBoost));

    //finally lerp to the cloud color base on the cloud value
    col.rgb = lerp(col.rgb, cloudColor, clouds);</span>
</code>
</pre>
</div>

            <p class="PageText">
                The last thing we have to do is just to mask out everything properly now that all of the added features are in place. For the moon we will change the final
                <code>lerp</code> to lerp by the horizon value multiplied by 1 minus the cloud value. And to the stars we will change how much of the stars value gets added
                by multiplying it with 1 - the clouds value. This should mask everything out nicely. 
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-hlsl">    //so we grab the moon tex and multiple the color
    float3 moonTex = tex2D(_MoonTex, moonUV).rgb * _MoonColor.rgb;

    //then we lerp to the color be how much of the moon is lit
    moonTex = lerp(col.rgb, moonTex * NDotL, saturate(NDotL));

    //then lerp to the final color masking out anything uner the horizon and anywhere there is clouds as they should be infron of the moon
    col.rgb = lerp(col.rgb, moonTex, horizonValue <span class="addition">* (1 - clouds)</span>);
    
...

    //then adjust the final color
    stars -= twinkle;
    stars = saturate(stars);

    //then lerp to the stars color masking out the horizon
    col.rgb = lerp(col.rgb, col.rgb + <span class="addition">(stars * (1 - clouds))</span>, night * horizonValue * (1 - step(0, sphere)));
    
    return col;
</code>
</pre>
</div>
            <div class="PageImageContainer">
                    <img class="PageImage" src="Media/CloudsSunset.png" alt="Our shader with clouds" />
                    <p class="PageImageText"> Our finished shader with clouds and moon visible</p>
            </div>

            <h2 class="Section" id="Part6">Part 6: Wrap up</h2>

            <p class="PageText">
                And with that we have finished our modding Unity&rsquo;s procedural skybox. We have added stars, clouds, and a moon. It is fairly customizable and can fit
                a variety of needs. I am sure somethings could be done differently and I would say feel free to experiment with it. A link to the final shader can be found
                <a href="https://github.com/FeralPug/FeralPug-Extending-the-Unity-Skybox/tree/main/FinalShader" title="Link to final shader" target="_blank">here</a> and all the
                textures that I used can be found <a href="https://github.com/FeralPug/FeralPug-Extending-the-Unity-Skybox/tree/main/Textures" title="Link to textures" target="_blank">here</a>.
                I hope you found this helpful and maybe even useful.
            </p>

            <p class="PageText">
                If you have any comments or something did not work for you, contact me via my
                <a href="https://feralpug.github.io/OtherPages/Support/Support.html" title="link to support page" target="_blank">support page</a>
                or DM me on twitter <a href="https://twitter.com/Feral_Pug" title="Link to my twitter page" target="_blank">@Feral_Pug</a>
                and I should respond to you soon. If you want to support me you can donate at 
                <a href="https://ko-fi.com/feral_pug" title="Link to my Ko-fi page" target="_blank">ko-fi.com/feral_pug</a>.
            </p>


            <!-- these are here just so I can grab the right formatting as we write

                <h2 class="Section" id="Part5">Part 5: Clouds</h2>

                <div class="PageImageContainer">
                    <img class="PageImage" src="Media/ExtendingSkyboxCapture.png" alt="Image of the final Result" />
                    <p class="PageImageText"> An example of what you can do with procedural skyboxes</p>
                </div>

                <div class="PageImageContainer">
                <div class="ImageSideBySideContainer">
                    <img class="PageSideBySide" src="Media/StarBending0.png" alt="Picture of our projected texture" />
                    <img class="PageSideBySide" src="Media/StarBending1.png" alt="Picture of our projected texture" />
                </div>
                <p class="PageImageText">
                    On the left _StarsBending is set to 0 and on the right _StarsBending is set to 1
                </p>
                </div>

                <p class="PageText">
                </p>

<div class="CodeHighlight">
<pre>
<code class="language-hlsl"></code>
</pre>
</div>
        -->
        </article>

        <div class="AsideContainer">
            <aside>
                <h2>Table of Contents</h2>
                <ul>
                    <li>
                        <a href="#PostStart" title="Jump to start of post">
                            Start
                        </a>
                    </li>
                    <li>
                        <a href="#Part1" title="Jump to part one">
                            Part 1: Background
                        </a>
                    </li>
                    <li>
                        <a href="#Part2" title="Jump to part two">
                            Part 2: Setup
                        </a>
                    </li>
                    <li>
                        <a href="#Part3" title="Jump to part three">
                            Part 3: Stars
                        </a>
                    </li>
                    <li>
                        <a href="#Part4" title="Jump to part four">
                            Part 4: Moon
                        </a>
                    </li>
                    <li>
                        <a href="#Part5" title="Jump to part five">
                            Part 5: Clouds
                        </a>
                    </li>
                    <li>
                        <a href="#Part6" title="Jump to part six">
                            Part 6: Wrap up
                        </a>
                    </li>
                </ul>
            </aside>
        </div>

    </main>

    <footer>
        <p>
            All resources found here are to be used freely for any projects, commercial, personal, or otherwise.
        </p>
    </footer>
</body>
</html>