<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Feral_Pug Codes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../../../../StyleSheets/EveryPage/stylesGeneral.css" />
    <link rel="stylesheet" href="../../../../StyleSheets/BlogStyles/stylesBlogPost.css" />
    <link rel="stylesheet" href="../../../../Prism/prism.css" />
    <script src="../../../../Scripts/markFixer.js" defer></script>
    <script src="../../../../Scripts/ScriptLoader.js" defer></script>

</head>
<body>
    <header>
        <div class="Banner" id="Top">Feral_Pug Codes</div>
    </header>

    <div class="SocialNav">
        <ul>
            <li>
                <a href="https://ko-fi.com/feral_pug" title="Link to my Ko-fi page" target="_blank">
                    <img src="../../../../Media/Icons/Ko-fiLogo.png" alt="Ko-Fi Logo" width="32" />
                </a>
            </li>
            <li>
                <a href="https://twitter.com/Feral_Pug" title="Link to my twitter page" target="_blank">
                    <img src="../../../../Media/Icons/twitterLogo.svg" alt="Twitter Logo" width="32" />
                </a>
            </li>
            <li>
                <a href="https://github.com/FeralPug" title="Link to my github page" target="_blank">
                    <img src="../../../../Media/Icons/GitHubLogo.png" alt="place holder picture" width="32" />
                </a>
            </li>
        </ul>
    </div>

    <div class="NavContainer">
        <nav>
            <ul>
                <li>
                    <a href="../../../../index.html">Home</a>
                </li>
                <li>
                    <a href="../../../GamesPage/Games.html">Games</a>
                </li>
                <li>
                    <a href="../../../Misc/Misc.html">VFX/WIP</a>
                </li>
                <li>
                    <a href="../../../Code/Code.html">Code Blog</a>
                </li>
                <li>
                    <a href="../../../Tools/Tools.html">Tools</a>
                </li>
                <li>
                    <a href="../../../Support/Support.html">Support</a>
                </li>
            </ul>
        </nav>
    </div>

    <main>
        <article>
            <h1 class="Section" id="PostStart">
                Trajectory Predictions and Particle Systems
            </h1>

            <p class="PageText">
                Player feedback is important for making games. If the player is not sure what consequence a certain action will have the game can feel unfair, and not fun. One
                instance of this is in a game where you throw some object through the air, maybe a golf game or something like Angry Birds. If the object of the game is to hit
                stuff, it will not be very fun if you do not know where you are actually aiming. A while back I needed to do this exact thing and I had a hard time drumming up
                high school physics or finding some resource online that gave me a quick, simple solution. So I wanted to write about how I achieved this.
            </p>

            <p class="PageText">
                In this blog post I will cover the math behind calculating a trajectory, how to implement that in code, how we can add decals to geomtrey where our projectile
                will collide with something, and how we can simulate physics in Unity to calculate complex trajectories.
            </p>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/PostCover.png" alt="Image of the final Result" />
                <p class="PageImageText"> This is what our final product will look like. Notice the decals drawn where ever we have collisions</p>
            </div>

            <h2 class="Section" id="Part1">Part 1: Setting Up Our Projectile Scene</h2>

            <p class="PageText">
                To start we are just going to get a basic scene set up with ground, a player launcher object, and a few scripts to allow control over the launcher and fire
                projectiles. I am guessing almost everyone reading this can set this up but I am going to go through it so anyone can use this post. If you want, skip to the
                end of this section there will be a link to where you can download everything you need to get going with the next section. Just be sure to add a <q>Player</q>
                layer and a <q>Projectile</q> layer, set the objects in the download to the appropriate layers and change the collision settings to stop these two layer
                from interacting.
            </p>

            <p class="PageText">
                To get setup make a new scene in Unity, add a plane, reset it&#39s transform and scale it up along all three axis. This will be our ground. Next create an empty
                game object, name it something like Launcher or Player. Go up to layer and create a new layer, I called mine <q>Player</q> and then add our empty launcher object
                to that layer. We do this because later we won&rsquo;t want our projectile colliding with our launcher as it exits the barrel. Then add a cube as a child to our
                launcher object, scale it up a bit in the z-axis, I set it to <q>3</q>. And then move it along the z-axis a bit, I moved mine to z = <q>1</q>.
            </p>

            <div class="PageImageContainer">
                <div class="ImageSideBySideContainer">
                    <img class="PageSideBySide" src="Media/LauncherSetupScene.png" alt="Our launcher model in scene view" />
                    <img class="PageSideBySide" src="Media/LauncherModelInspector.png" alt="The transform of our child cube object" />
                </div>
                <p class="PageImageText">
                    On the left we have our scene view of our launcher model, and on the right we have the transform of the child cube we added.
                </p>
            </div>

            <p class="PageText">
                First we will create some simple controls for our launcher. We will limit these to rotation and firing our projectile. Make a script called <q>AimController</q>.
                Add a public <code>Vector2</code> to control the rotation speed of our launcher. Then create a private <code>Rotate</code> function. Inside the function we will
                grab the eulerAngles representation of our object&rsquo;s rotation. Then grab the horizontal and vertical input axis multiplied by the respective rotation speed and
                deltaTime. Add the input amount to the eulerAngles we grabbed before and apply it back to our transform with <code>Quaternion.Euler()</code>. Then call the
                function in update. Add the script to the root of the launcher object and set the rotation speed to what ever you like. I went with 45 for both x and y. This will
                give us all the movement control we need. Your script should look like snippet below.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">public class AimController : MonoBehaviour
{
    public Vector2 rotSpeed;

    // Update is called once per frame
    void Update()
    {
        Rotate();
    }

    void Rotate()
    {
        Vector3 currentRotation = transform.rotation.eulerAngles;

        Vector3 desRot = new Vector3();
        desRot.x = Input.GetAxis("Vertical") * rotSpeed.x;
        desRot.y = Input.GetAxis("Horizontal") * rotSpeed.y;

        desRot *= Time.deltaTime;

        currentRotation += desRot;

        transform.rotation = Quaternion.Euler(currentRotation);
    }
}
</code>
</pre>
                <p class="PageImageText">
                    Simple code to get rotation control for our launcher.
                </p>
            </div>

            <p class="PageText">
                Now to get get firing control for our launcher. First, add a sphere to our scene and give it a <code>RigidBody</code> component.
                Create a new <code>Projectile</code> layer and add it to that new layer. I also added a black, metallic material to it to set it apart.
                Then make a prefab out of that sphere
                so that we have a projectile that our launcher can instantiate into the scene when we want to fire a new projectile. Then go Edit >
                ProjectSettings > Physics and uncheck the box for the Player layer and the Projectile layer in the Layer Collision Matrix section. This will stop our projectile
                from colliding with our launcher when it is first fired.
            </p>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/CollisionMatrix.png" alt="Settings for the collision matrix" />
                <p class="PageImageText"> Uncheck that box for the Player and Projectile layer. Ignore that Invisible layer, we will get to that later.</p>
            </div>

            <p class="PageText">
                Now create two more scripts, one called <code>LaunchController</code> and the other called <code>ProjectileController</code>. The <code>LaunchController</code> will be
                responsible for instantiating our projectile and the <code>ProjectileController</code> will provide us access to the <code>RigidBody</code> of the projectile
                so that we can easily set it&rsquo;s velocity.
            </p>

            <p class="PageText">
                The <code>ProjectileController</code> will just have a public <code>RigidBody</code> field that we will assign in the inspector so that we will have easy access to it
                from the <code>LaunchController</code>. The <code>LaunchController</code> is pretty simple.
                It will have two public fields, one for the initial speed of our projectile and one for the projectile prefab.
                Then in update we check for a button press and if so we call a function that will instantiate an instance of our projectile prefab and set the velocity of
                it&rsquo;s rigid body to be equal to the launchers forward vector times the initial speed. Add the <code>LaunchController</code> to the root of the launcher
                object and add the <code>ProjectileController</code> to the projectile prefab.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">public class ProjectileController : MonoBehaviour
{
    public Rigidbody Rigidbody;
}
</code>
</pre>
                <p class="PageImageText">
                    Our <code>ProjectileController</code>
                </p>
            </div>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">public class LaunchController : MonoBehaviour
{
    public float launchVelocity = 15f;
    public ProjectileController projectilePrefab;

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            LaunchProjectile();
        }
    }

    void LaunchProjectile()
    {
        ProjectileController projectile = Instantiate(projectilePrefab, transform.position, Quaternion.identity);

        projectile.Rigidbody.velocity = transform.forward * launchVelocity;
    }
}
</code>
</pre>
                <p class="PageImageText">
                    And our <code>LaunchController</code>
                </p>
            </div>

            <p class="PageText">
                Add the <code>LaunchController</code> to the root of the launcher object and add the <code>ProjectileController</code> to the projectile prefab. Then assign
                the <code>RigidBody</code> of the projectile to the public field of the <code>ProjectileController</code>. Then add the projectile prefab to the public field
                of the <code>LaunchController</code> and you should be all set to launch spheres to your heart&rsquo;s content.
            </p>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/LauncherSetup.gif" alt="Launching projectiles" />
                <p class="PageImageText"> OK we can launch stuff, now lets get to the math!</p>
            </div>

            <p class="PageText">
                If everything went right for you, you should have something similar to the above gif. If you skipped ahead, or something is not working,
                you can grab the package for this scene and all of the code
                <a href="https://github.com/FeralPug/TrajectoryPredictions/tree/main/Part1:%20Setup" title="Link to resources on github" target="_blank">here</a>.
                Just make sure you set the layers and physics settings accordingly.
            </p>

            <h2 class="Section" id="Part2">Part 2: Trajectory Math</h2>

            <p class="PageText">
                Ok, so now that we have a way to launch objects lets start talking about how we can calculate the trajectory of our projectile. To do this we need two equations.
                We need one to determine the horizontal position of the projectile as a function of time, and we need another one for the vertical position. Then we can
                add these two positions together and get our position at any time. For now we will assume only gravity acts on our projectile.
            </p>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/PositionEquations.png" alt="Position equations" />
                <p class="PageImageText">
                    The two equations we need to calculate the posision of our projectile. On top we have our horizontal position and
                    on bottom we have our vertical position. Pos is the final position, Pos<sub>0</sub> is the starting position, V<sub>0</sub> is the starting velocity,
                    t is time, and g is gravity.
                </p>
            </div>

            <p class="PageText">
                These equations make sense to us. We start at some position, we move by some velocity every unit of time, and if we have acceleration our velocity is changed
                by some amount every unit of time. The gravity term looks a little funny but if you have ever taken calculus, it is just the power rule going on. And if you
                have not taken calculus, don&rsquo;t worry, we do not need to have a complete understanding of these equations. To use these equations we are missing something
                though, we need the velocity broken down into vertical and horizontal components.
            </p>

            <p class="PageText">
                Because Unity can provides us with a normalized Vector3 for our launch direction, we could cheat to get these two velocities. Actually we have three, X, Y,
                and Z. The X, Y, and Z components of this Vector3 are the X, Y, and Z components of any point on the unit circle, or sphere.
                We could just multiply them by the total initial velocity and that would give us the horizontal and vertical components in all three directions.
                However, I think it is worth while to understand the triganometry of actauly calculating these vectors on their own, as understanding these is useful in
                a lot of different game developement programming.
            </p>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/ProjectileMotionGraphic.png" alt="Visual representation of our projectile motion" />
                <p class="PageImageText">
                    This is the real problem we are solving. We need to figure out that launch angle and then we can use math to get the
                    horizontal and vertical components. Photo credit toppr.com.
                </p>
            </div>

            <p class="PageText">
                If we can remember our triganometry from high school, we remember that the <code>sin</code> of the angle equals the length of the opposite side of the triangle
                divided by the hypotenuse of the triangle. So the sin of the angle multiplied by the length of the hypotenuse, or our launch speed, is our vertical initial
                velocity. For our horizontal velocity we do the same but with the <code>cos</code> because the cos of the angle equals the adjacent side of the triangle
                divided by the hypotenuse of the triangle. The cos of the angle multiplied by our launch speed is our initial horizontal velocity. We then would just need to
                break that down into the X and Z components. Easy! To get the angle we just work backwards. We know the Y component of our launch direction. The <code>arcsin</code>
                of this gives of the angle off of the horizon. Also easy!
            </p>

            <p class="PageText">
                In code all we have to do is calculate these velocities following the above logic and then use the two formulas from above to get the virtical and horizonal
                parts of our position and add them together. There is just one small problem, time. How long do we do this for. It would be helpful if we could know how long
                until we were going to hit the ground. Well, when our Y position = 0 we know we are hitting the ground. If we set that second forumla equal to 0 it looks a lot
                like the condition for using the quadratic formula to solve for t. And it is! We can use the quadratic formula to solve for t!
            </p>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/QuadraticFormula.png" alt="Launching projectiles" />
                <p class="PageImageText">
                    Substitue t for x and this is exactly the problem we have to solve.
                </p>
            </div>

            <p class="PageText">
                And with that we have all the logic we need to calulate our trajectory. We figure out our initial velocities, solve for how long our projectile will be in the
                air, and then step through the position formulas at what ever pace we want to get the positions along our trajectory. All we have to do is write this in code.
            </p>

            <h2 class="Section" id="Part3">Part 3: Writing the Code</h2>

            <p class="PageText">
                So the things we need are our launch direction, our launch angle, our initial velocity, and the variables for the quadratic formula: a, b, and c. To do this,
                create a <code>TrajectoryCalculator</code> script. Remove the inheritance from Monobehavior, delete the <code>Start</code> and <code>Update</code> methods and
                make the <code>TrajectoryCalculator</code> at <code>static class</code>. We will put all of the methods for getting the information about our trajectory in this
                class and because it is static any object can easily get access to these methods. Lets first get the launch direction, and the launch angle. Add a method for
                getting the launch direction and a method for calculating the launch angle from that direction. Lets keep all of this private because we will provide a single
                public method that other objects can use to interface with our calculator.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">using UnityEngine;

public static class TrajectoryCalculator
{
    static Vector3 GetLaunchDirection(Transform launchTransform)
    {
        return launchTransform.forward;
    }

    static float GetLaunchAngle(Vector3 launchDirection)
    {
        return Mathf.Asin(launchDirection.y);
    }
}
</code>
</pre>
                <p class="PageImageText">
                    The simple start of our calculator. We could get away with not having methods for these calculations but it makes it easy to change later how these
                    parts of the process work. For example if we wanted to change how we calculate the launch direction we would just need to change this method and not
                    any code that uses it.
                </p>
            </div>

            <p class="PageText">
                Now what we will do is declare a public static method that will take a some parameters that our <code>LaunchController</code> has and processes them to give us
                the needed information about out trajectory. We will have it return a <code>TrajectoryInfo</code> struct that will contain all of this information. Lets declare
                that in its own file because it will be used by our <code>LaunchController</code> as well. So create this script in Unity. This struct will contain the launch
                direction, the launch position, the initial speed, the launch angle, and the time to floor or ground.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">using UnityEngine;

public struct TrajectoryInfo
{
    public Vector3 LaunchDirection { get; private set; }
    public Vector3 StartingPosition { get; private set; }
    public float InitialHorizontalSpeed { get; private set; }
    public float InitialVerticalSpeed { get; private set; }
    public float TimeToFloor { get; private set; }

    public TrajectoryInfo(Vector3 launchDirection, Vector3 startingPos, float initialSpeed, float launchAngle, float timeToFloor)
    {
        LaunchDirection = launchDirection;
        StartingPosition = startingPos;
        InitialHorizontalSpeed = Mathf.Cos(launchAngle) * initialSpeed;
        InitialVerticalSpeed = Mathf.Sin(launchAngle) * initialSpeed;
        TimeToFloor = timeToFloor;
    }
}
</code>
</pre>
            </div>

            <p class="PageText">
                Now before we write our <code>GetTrajectoryInfo</code> method in our calculator we need to write the code to get what I am calling <code>TimeToFloor</code>.
                To do this we will add a private struct to our calculator class that will hold the variables of the quadratic formula. Then we will pass an instance of this
                struct into a method that will use the quadratic formula to calculate the time to floor. The code for the method that calculates the quadratic formula is pretty
                straight forward but I will point out a few things.
            </p>

            <p class="PageText">
                First lets say we want to solve for a time besides when y = 0. This y = 0 constraint is kind of limiting. If our ground is at a height of -5 for example and not
                0 this doesn&rsquo;t really help. But we can fix this by setting y to what ever height we want in our quadradic formula and then subtracting that height from
                both sides of the equation. So instead of C in our equation equaling the starting height of our projectile, C will equal the starting height minus the floor,
                what ever that may be. This allows us a bit more freedom in using this calculation.
            </p>

            <p class="PageText">
                The second thing to be aware of is that square root. We do not want to try and take the square root of a negative number as it will return <code>NAN</code>.
                This would only happen if we either turned off gravity or if we set the floor to a height higher than our projectile will go. Both of these are very edge cases
                that we can mostly ignore. But we should check to see if we are going to take the square root of a negative number before we do it, and return -1 if we are so that
                what ever is calling the method can be aware that we are not providing valid trajectory info.
            </p>

            <p class="PageText">
                With that being said add the following to our <code>TrajectoryCalculator</code> class.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">  static QuadParams GetQuadParams(float initialVelocity, float projectileAngle, float startingHeight, float floor)
    {
        float a = .5f * Physics.gravity.y;
        float b = initialVelocity * Mathf.Sin(projectileAngle);
        float c = startingHeight - floor;

        return new QuadParams(a, b, c);
    }

    static float GetTimeToFloor(QuadParams quadParams)
    {
        float determinant = (quadParams.B * quadParams.B) - (4 * quadParams.A * quadParams.C);

        if (determinant < 0)
        {
            Debug.LogWarning("Trying to take square root of negative number, check gravity in physics settings!!!");
            return -1;
        }
        else
        {
            determinant = Mathf.Sqrt(determinant);
        }

        return (-quadParams.B - determinant) / (2 * quadParams.A);
    }

    struct QuadParams
    {
        public float A { get; private set; }
        public float B { get; private set; }
        public float C { get; private set; }

        public QuadParams(float a, float b, float c)
        {
            A = a;
            B = b;
            C = c;
        }
    }
</code>
</pre>
            </div>

            <p class="PageText">
                Now all we have to do is add the <code>GetTrajectoryInfo</code> method to our calculator class and our launcher can get the information it needs to describe
                the trajectory of the projectile. Add the following to our <code>TrajectoryCalculator</code> class.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">  public static TrajectoryInfo GetTragectoryInfo(Transform fireTransform, float initialSpeed, float startingHeight, float floor)
    {
        //we get the fireDirection from the forward of the fireTransform
        Vector3 fireDirection = GetLaunchDirection(fireTransform);

        //then we use that to get the fire angle off the horizon
        float fireAngle = GetLaunchAngle(fireDirection);

        //then with that info and some of the original parameters we can calculate a, b, and c of the quadratic formula
        //the QuadParams struct just wraps those up together for us
        QuadParams quadParams = GetQuadParams(initialSpeed, fireAngle, startingHeight, floor);

        //then we can use that to get the timeToFloor
        float timeToFloor = GetTimeToFloor(quadParams);

        //and then we have all the info to describe the trajectory of our projectile
        return new TrajectoryInfo(fireDirection, fireTransform.position, initialSpeed, fireAngle, timeToFloor);
    }
</code>
</pre>
            </div>

            <p class="PageText">
                Before we return to our <code>LaunchController</code> we still have one more thing to do. We need to use this trajectory info to calculate the points along
                the trajectory. Now our launcher could do this but I like having the calculator do this for us. Our <code>LaunchController</code> could start to get complicated
                as our game gets more complicated. Also other objects might want to be able to do this and that would mean we have to re-write this code in every class that
                wants to do trajectory calculations.
            </p>

            <p class="PageText">
                So with that being said lets add a function that will step through our trajectory storing the positions in a Vector3 array. We pass in the trajectory info,
                the number of points we want to record, and array that can store the points. The array is an <code>out</code> type because later we will want to return
                different data from this function. It is not completely necessary as an array is a reference type but I like to this it helps communicate how this function
                works a little better. Then we calculate the time step for our trajectory, size the array, and calculate the positions using our two original formulas
                that we talked about earlier in a for loop.
            </p>

            <p class="PageText">
                The only thing to note is
                that we have to adjust our horizontal velocity. This is because we split our total velocity into vertical and horizontal, not X, Y, and Z components. We could
                easily change the other parts of our code, and probably should, but I wanted to highlight the triganometry, and the extra cpu cycles for this is pretty small.
                Add the following code to our <code>TrajectoryCalculator</code> class.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">  //this formula takes in out trajectory info and some info and calculates the positions along the trajectory
    public static void GetTrajectoryPoints(TrajectoryInfo trajectoryInfo, int resolution, out Vector3[] points)
    {
        //calculate the time between points on our trajectory
        float timeStep = trajectoryInfo.TimeToFloor / resolution;

        //and assign the points array to have the correct size, we use + 1 because we want to go all the way to the floor
        points = new Vector3[resolution + 1];

        //we have to use the normalized vector of the horizontal components of our fireDirection, because they need to have a magnitude of 1
        //unless there is no horizontal comonent
        Vector2 horizontal = new Vector2(trajectoryInfo.LaunchDirection.x, trajectoryInfo.LaunchDirection.z);
        if (horizontal.sqrMagnitude != 0f)
        {
            horizontal = horizontal.normalized;
        }

        //then we just step through assigning all of the points
        for (int i = 0; i < points.Length; i++)
        {
            //current time of along trajectory
            float currentTime = timeStep * i;

            //then we just need to brake it down into x and z components by using the direction
            float xPart = horizontal.x * trajectoryInfo.InitialHorizontalSpeed;
            float zPart = horizontal.y * trajectoryInfo.InitialHorizontalSpeed;

            //and apply the time to get the x and y positions
            float xPos = xPart * currentTime + trajectoryInfo.StartingPosition.x;
            float zPos = zPart * currentTime + trajectoryInfo.StartingPosition.z;

            //then for the y position we just use the formula from above
            float yPos = trajectoryInfo.StartingPosition.y + trajectoryInfo.InitialVerticalSpeed * currentTime + (.5f * Physics.gravity.y) * (currentTime * currentTime);

            Vector3 point = new Vector3(xPos, yPos, zPos);
            points[i] = point;          
        }
    }
</code>
</pre>
            </div>


            <p class="PageText">
                Now lets go back to our launcher object. Add a <code>LineRenderer</code> component to the root object and set the setting as you like. We are going to create
                a <code>TrajectoryDrawer</code> class that we will add to our launcher that will be responsible for getting the trajectory positions and assigning them to the
                positions of the line renderer. To start we will create a struct in this class that will hold the drawing settings, for now the resolution of our trajectory and
                the floor. Then we will also add private fields for the <code>LaunchController</code> and the <code>LineRenderer</code> along with a <code>Vector3[]</code>. We
                will grab the needed references in <code>Awake</code>.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">using UnityEngine;

[RequireComponent(typeof(LineRenderer), typeof(LaunchController))]
public class TrajectoryDrawer : MonoBehaviour
{
    public TrajectoryDrawingSettings drawSettings;

    [System.Serializable]
    public struct TrajectoryDrawingSettings
    {
        public int resolution;
        public float floor;
    }

    LineRenderer lineRenderer;
    LaunchController launchController;

    Vector3[] points;

    private void Awake()
    {
        lineRenderer = GetComponent&#60LineRenderer&#62();
        launchController = GetComponent&#60LaunchController&#62();
    }
}
</code>
</pre>
            </div>

            <p class="PageText">
                OK, now in update we will call a method that will get the trajectory info, and if we get a valid trajectory back we will get the points along the trajectory
                and then assign them to the line renderer. And if you haven&rsquo;t already, add the <code>TrajectoryDrawer</code> component to our launcher object.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">  private void Update()
    {
        CalculateTrajectoryPath();
    }

    void CalculateTrajectoryPath()
    {
        TrajectoryInfo trajectoryInfo = TrajectoryCalculator.GetTragectoryInfo(transform, launchController.launchVelocity, transform.position.y, drawSettings.floor);

        if (trajectoryInfo.TimeToFloor >= 0)
        {
            TrajectoryCalculator.GetTrajectoryPoints(trajectoryInfo, drawSettings.resolution, out points);
        }

        lineRenderer.positionCount = points.Length;
        lineRenderer.SetPositions(points);
    }
</code>
</pre>
            </div>

            <p class="PageText">
                Now one little optimization we will make is to only calculate the trajectory if our launchers transform has changed. Otherwise we will just be calculating the
                same data that we already have. In <code>TrajectoryDrawer</code> we will add a private bool that will keep track of if we need to recalculate the
                trajectory. We will also add a public method to set this bool. Then in the <code>AimController</code> we will grab a reference to the TrajectoryDrawer
                and if we have changed our rotation we will tell the TrajectoryDrawer that we need to recalculate the trajectory. Make the following changes.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">public class TrajectoryDrawer : MonoBehaviour
{
    public TrajectoryDrawingSettings drawSettings;

    [System.Serializable]
    public struct TrajectoryDrawingSettings
    {
        public int resolution;
        public float floor;
    }

    LineRenderer lineRenderer;
    LaunchController launchController;

    Vector3[] points;

    <span class="addition">bool isDirty;

    public void SetDirty()
    {
        isDirty = true;
    }</span>

    private void Awake()
    {
        lineRenderer = GetComponent&#60LineRenderer&#62();
        launchController = GetComponent&#60LaunchController&#62();
    }

    private void Update()
    {
        <span class="addition">if (isDirty)
        {</span>
            CalculateTrajectoryPath();

            isDirty = false;
        <span class="addition">}</span>
    }

    void CalculateTrajectoryPath()
    {
        TrajectoryInfo trajectoryInfo = TrajectoryCalculator.GetTragectoryInfo(transform, launchController.launchVelocity, transform.position.y, drawSettings.floor);

        if (trajectoryInfo.TimeToFloor >= 0)
        {
            TrajectoryCalculator.GetTrajectoryPoints(trajectoryInfo, drawSettings.resolution, out points);
        }

        lineRenderer.positionCount = points.Length;
        lineRenderer.SetPositions(points);
    }
}
</code>
</pre>
            </div>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">public class AimController : MonoBehaviour
{
    public Vector2 rotSpeed;

    <span class="addition">TrajectoryDrawer trajectoryDrawer;

    private void Awake()
    {
        trajectoryDrawer = GetComponent&#60TrajectoryDrawer&#62();
    }</span>

    // Update is called once per frame
    void Update()
    {
        Rotate();
    }

    void Rotate()
    {
        Vector3 currentRotation = transform.rotation.eulerAngles;

        Vector3 desRot = new Vector3();
        desRot.x = Input.GetAxis("Vertical") * rotSpeed.x;
        desRot.y = Input.GetAxis("Horizontal") * rotSpeed.y;
     
        <span class="addition">if(desRot != Vector3.zero && trajectoryDrawer != null)
        {
            trajectoryDrawer.SetDirty();
        }</span>

        desRot *= Time.deltaTime;

        currentRotation += desRot;

        transform.rotation = Quaternion.Euler(currentRotation);
    }
}
</code>
</pre>
            </div>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/TrajectoryPredicted.gif" alt="Gif of our predicted trajectory" />
                <p class="PageImageText"> Nice, look at that trajectory</p>
            </div>

            <p class="PageText">
                Cool, and with that we have our trajectory calculations taken care of. From here we could go a lot of different directions. We could add calculations to
                take into account other forces like drag or friction, we coud add bounce prediction. None of this would be <em>that</em> hard to add,
                we would just need to account for these extra variables in our equations.
            </p>

            <p class="PageText">
                The thing is though, we can really only do this if <em>we</em> handle all of the
                physics. We would have to write all the code for how collisions are handled. Not impossible, but not really the point of this blog post.
                The reason for this is that Unity&rsquo;s physics code is complex, and even if we could accurately predict how it would react we might get
                rounding errors and such that still leave us with the wrong calculations.
            </p>

            <p class="PageText">
                I will leave writing your own collision handling as an exercise for the reader. If you want help,
                <a href="https://feralpug.github.io/OtherPages/Support/Support.html" title="Link to contact page" target="_blank">contact me</a>
                and I might write a post about how we could do that. Instead I think it will be more fun to add some decals to where our projectile will collide and
                then wrap up this post by showing how we can simulate Unity&rsquo;s physics engine to calculate more complex trajectories.
            </p>

            <p class="PageText">
                You can grab all of the code up to this point
                <a href="https://github.com/FeralPug/TrajectoryPredictions/tree/main/Part3:%20Writing%20Code" title="Link to part 3 code" target="_blank">here</a>.
            </p>

            <h2 class="Section" id="Part4">Part 4: Decals And Particle Systems</h2>

            <p class="PageText">
                To add decals to where our projectile collides with other objects we will use particle systems. If we add a particle system to our launcher object we can
                write a script that controls the particle system from code. All we have to do is figure out where to put the particles and how to orientate them. Before
                we set up our particle system lets handle that first problem, where to put the particles.
            </p>

            <p class="PageText">
                Currently our trajectory calculation has no idea of when it is
                going to hit something, except for the floor value we define. But if there is an obstacle in the way we should account for that. To do this handle this, when
                we loop through our position equations to get the points of our trajectory, we can just <code>RayCast</code> from one point to the next, stopping and storing
                the position of where ever we hit something.
            </p>

            <p class="PageText">
                To do this we will add a method to our <code>TrajectoryCalculator</code> class that will take in three parameters: the point we are rayCasting from, the point
                we are rayCasting to, and a layerMask that will mask out our launcher object, because otherwise it would think we are going to hit the launcher. This method is
                pretty straight forward. We first get a vector going from out first point to our second point, calculate the distance, and then calculate the direction that this
                new vector is pointing in. Then we do the rayCast and return the <code>RayCastHit</code> generated from the rayCast.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">static RaycastHit FindCollisionPoint(Vector3 from, Vector3 to, LayerMask collisionMask)
{
    RaycastHit hit;
    Vector3 vector = to - from;
    float distance = vector.magnitude;
    Vector3 direction = vector / distance;

    Physics.Raycast(from, direction, out hit, distance, collisionMask);

    return hit;
}</code>
</pre>
                <p class="PageImageText">
                    Add this method to our <code>TrajectoryCalculator</code> class.
                </p>
            </div>

            <p class="PageText">
                Then in our <code>GetTrajectoryPoints</code> method we just have to call this function when appropriate, and if we hit something use that hit point instead of
                the point we calculated. We need to add a layerMask parameter to this function because we need it for our rayCast.
                If we hit something we can return early because the rest of our trajectory doesn&rsquo;t matter. We then also resize
                the array of points because otherwise we will have a lot of <code>Vector3.zero</code> and our line will be all wrong. If we don&rsquo;t hit something we just do
                as normal.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp"><span class="addition">Vector3 point = new Vector3(xPos, yPos, zPos);</span>

if(i > 0)
{
    RaycastHit hit = FindCollisionPoint(points[i - 1], point, collisionMask);

    if (hit.collider)
    {
        points[i] = hit.point;
        System.Array.Resize(ref points, i + 1);
        return;
    }
    else
    {
        points[i] = point;
    }
}
else
{
    points[i] = point;
}                     </code>
</pre>
                <p class="PageImageText">
                    Add everything after the highlighted portion inside of thr for loop in our <code>GetTrajectoryPoints</code> method in our <code>TrajectoryCalculator</code>
                    class.
                </p>
            </div>

            <p class="PageText">
                The last thing we need to change our <code>TrajectoryDrawer</code> class to have a layerMask field that we can set. I set mine to everything except the player
                and the projectile layers, because those are the ones we are not concerned with. Then we just add that to the call to <code>GetTrajectoryPoints</code> and we
                are all set to go.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">public class TrajectoryDrawer : MonoBehaviour
{
    public TrajectoryDrawingSettings drawSettings;

    [System.Serializable]
    public struct TrajectoryDrawingSettings
    {
        public int resolution;
        public float floor;
        <span class="addition">public LayerMask collisionMask;</span>
    }

    ...

    void CalculateTrajectoryPath()
    {
        TrajectoryInfo trajectoryInfo = TrajectoryCalculator.GetTragectoryInfo(transform, launchController.launchVelocity, transform.position.y, drawSettings.floor);

        if (trajectoryInfo.TimeToFloor >= 0)
        {
            TrajectoryCalculator.GetTrajectoryPoints(trajectoryInfo, drawSettings.resolution, out points<span class="addition">, drawSettings.collisionMask</span>);
        }

        lineRenderer.positionCount = points.Length;
        lineRenderer.SetPositions(points);
    }</code>
</pre>
                <p class="PageImageText">
                    Add the highlighted changes to our <code>TrajectoryDrawer</code> class and make sure to set it correctly in the inspector.
                </p>
            </div>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/CollisionDetection.gif" alt="Proper collision detection for our trajectory" />
                <p class="PageImageText"> Now we know where we are going to hit something</p>
            </div>

            <p class="PageText">
                Now to set this up with decals we first will setup the particle system that we are going to use for drawing the decals. Lets first make the material that we will
                be using to draw our decals with. Create a new material and set the shader to Particle > StandardUnlit. Set the Rendering Mode to Fade and the Color Mode to
                multiply. Then import the below target texture, set the alpha is transparency check box in the import settings and assign this texture to be the Albedo texture
                of our material.
            </p>

            <div class="PageImageContainer">
                <div class="ImageSideBySideContainer">
                    <img class="PageSideBySide" src="Media/Target.png" alt="Target texture used for particle" />
                    <img class="PageSideBySide" src="Media/MaterialSettings.png" alt="Material Settings" />
                </div>
                <p class="PageImageText">
                    On the left the target texture to use on the material and the material settings on the right
                </p>
            </div>

            <p class="PageText">
                Now add an empty gameObject to our launcher and name it something about particle systems.
                Add a Particle System and turn off all of the modules except for the Renderer module at the bottom. In the Renderer
                Module set the render Alignment to World and the material to be the material we just created. Also in the main Module set the <code>PlayOnAway</code> off.
            </p>

            <div class="PageImageContainer">
                <div class="ImageSideBySideContainer">
                    <img class="PageSideBySide" src="Media/MainModule.png" alt="Main Module Setting" />
                    <img class="PageSideBySide" src="Media/RendererModule.png" alt="Renderer Module Settings" />
                </div>
                <p class="PageImageText">
                    On the left is the Main Module settings and on the right is the Renderer Module Settings
                </p>
            </div>

            <p class="PageText">
                Create a <code>ParticleSystemController</code> script and attach it to our new particle system object. To use the particle system to draw decals we will set the
                properties of the particles in our system from code when ever we have a collision. To do this we will need to be able to set some values on each particle in the
                system. This will require us to keep two arrays one for the particles in the system and one for the data that we want to set on each particle. We will define this
                data in a new struct.
            </p>

            <p class="PageText">
                Create a new script and call it <code>ParticleData</code> and change it to a struct. This struct will keep track of 2 properties, the
                position of the particle, and the rotation of the particle. Particles in Unity use Euler angles for their rotation so we will store the rotation as a Vector3
                instead of a Quaternion.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">public struct ParticleData
{
    public Vector3 position;
    public Vector3 rotation;
}</code>
</pre>
                <p class="PageImageText">
                    Our Particle Data struct.
                </p>
            </div>

            <p class="PageText">
                Then in our <code>ParticleSystemController</code> script we will add fields for our <code>Particle[]</code>, our <code>ParticleData[]</code>, our
                <code>ParticleSystem</code>, a settings Struct, and an int to keep track of which particle was last set. We will grab all the required references and setup
                everything in the awake method.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">[RequireComponent(typeof(ParticleSystem))]
public class ParticleSystemController : MonoBehaviour
{
    public ParticleSystemSettings systemSettings;

    [System.Serializable]
    public struct ParticleSystemSettings
    {
        public int maxParticles;
        public float particleSize;
    }

    ParticleSystem _particleSystem;

    ParticleSystem.Particle[] particles;
    ParticleData[] particleData;

    int lastSetParticleDataIndex = -1;

    private void Awake()
    {
        _particleSystem = GetComponent&#60ParticleSystem&#62();
        ResetParticleSystem();
    }

    void ResetParticleSystem()
    {
        particles = new ParticleSystem.Particle[systemSettings.maxParticles];
        particleData = new ParticleData[systemSettings.maxParticles];

        for (int i = 0; i < particleData.Length; i++)
        {
            particleData[i] = new ParticleData();
        }

        _particleSystem.Clear();
    }
}</code>
</pre>
                <p class="PageImageText">
                    The basic setup of our <code>ParticleSystem</code> controller
                </p>
            </div>

            <p class="PageText">
                The rest of our <code>ParticleSystemController</code> will consist of three methods. We will have a <code>SetParticle</code> method, a <code>ClearParticles</code>
                method, and a <code>DisplayParticles</code> method. Our <code>TrajectoryDrawer</code> will, if a collision is found, clear out the particle system, set the
                desired particle, and then display the particles.
            </p>

            <p class="PageText">
                The <code>ClearParticles</code> method will just loop through the two arrays setting a few properties to effectivly turn of the particles. We only have to do
                this up to the last set index because <code>Particle</code> is a struct that has default values of an invisible particle. So any particles we haven&rsquo;t touched
                will just be invisible. Then we set the lastSetIndex to be -1.
            </p>
            <p class="PageText">
                The <code>SetParticle</code> method will get the data from the RayCastHit and set the data accordingly on the next index to set. The only thing to note here is that
                we have to flip the z of the collision normal or our particle will be backwards.
                The <code>DisplayParticles</code> method will just loop up to the lastSetIndex and read the data out of the <code>ParticleData[]</code> and set it on the appropriate
                particle. Add the following methods to our <code>ParticleSystemController</code>.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">public void SetParticle(RaycastHit collisionData)
{
    int index = lastSetParticleDataIndex + 1;

    if(index < systemSettings.maxParticles)
    {
        ParticleData particle = new ParticleData();

        particle.position = collisionData.point + collisionData.normal * 0.01f;
        Vector3 normal = collisionData.normal;
        normal.z *= -1;
        particle.rotation = Quaternion.LookRotation(normal).eulerAngles;
        particleData[index] = particle;

        lastSetParticleDataIndex = index;
    }
}

public void ClearParticles()
{
    for (int i = 0; i <= lastSetParticleDataIndex; i++)
    {
        particles[i].startColor = Color.clear;
    }

    lastSetParticleDataIndex = -1;
}

public void DisplayParticles()
{
    for (int i = 0; i <= lastSetParticleDataIndex; i++)
    {
        particles[i].position = particleData[i].position;
        particles[i].rotation3D = particleData[i].rotation;
        particles[i].startSize = systemSettings.particleSize;
        particles[i].startColor = Color.white;
    }

    _particleSystem.SetParticles(particles, particles.Length);
}</code>
</pre>
            </div>

            <p class="PageText">
                But in order to do this our drawer needs to know about the collision that occured. We will have to change our
                <code>GetTrajectoryPoints</code> method in our <code>TrajectoryCalculator</code> to give us the RaycastHit variable when it finds a collision. If it doesn&rsquo;t
                find a collision we will just manually set the position and orientation of the RayCastHit at the end of the method.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">public static void GetTrajectoryPoints(TrajectoryInfo trajectoryInfo, int resolution,
    out Vector3[] points<span class="addition">, out RaycastHit raycastHit</span>, LayerMask collisionMask)
{
    <span class="addition">raycastHit = new RaycastHit();</span>

    //calculate the time between points on our trajectory
    float timeStep = trajectoryInfo.TimeToFloor / resolution;

...

            if(i > 0)
            {
                <span class="addition">raycastHit</span> = FindCollisionPoint(points[i - 1], point, collisionMask);

                if (raycastHit.collider)
                {
                    points[i] = <span class="addition">raycastHit</span>.point;
                    System.Array.Resize(ref points, i + 1);
                    return;
                }
                else
                {
                    points[i] = point;
                }
            }
            else
            {
                points[i] = point;
            }                     
        }

    <span class="addition">raycastHit.point = points[points.Length - 1];
    raycastHit.normal = Vector3.up;</span>
}
</code>
</pre>
                <p class="PageImageText">
                    Make the highlighted changes
                </p>
            </div>

            <p class="PageText">
                Now back in our drawer we just have to declare a public <code>ParticleSystemController</code>, assign it in the inspector, and then
                tell the praticle system to draw at the new position. Dont forget to set a max particles number and size to our <code>ParticleSystemController</code>. I
                am using 100 and 2.5 for the size.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">public class TrajectoryDrawer : MonoBehaviour
{
    <span class="addition">public ParticleSystemController particleSystemController;</span>

    public TrajectoryDrawingSettings drawSettings;

    [System.Serializable]
    public struct TrajectoryDrawingSettings
    {
        public int resolution;
        public float floor;
        public LayerMask collisionMask;
    }

...

    void CalculateTrajectoryPath()
    {
        TrajectoryInfo trajectoryInfo = TrajectoryCalculator.GetTragectoryInfo(transform, launchController.launchVelocity, transform.position.y, drawSettings.floor);

        if (trajectoryInfo.TimeToFloor >= 0)
        {
            TrajectoryCalculator.GetTrajectoryPoints(trajectoryInfo, drawSettings.resolution, out points, <span class="addition">out RaycastHit hit,</span> drawSettings.collisionMask);

            <span class="addition">particleSystemController.ClearParticles();
            particleSystemController.SetParticle(hit);
            particleSystemController.DisplayParticles();</span>
        }

        lineRenderer.positionCount = points.Length;
        lineRenderer.SetPositions(points);
    }</code>
</pre>

                <p class="PageImageText">
                    Make the highlighted changes to our <code>TrajectoryDrawer</code>
                </p>
            </div>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/TrajectoryWithTarget.gif" alt="Our trajectory with target decal" />
                <p class="PageImageText"> Target locked, Captain. Fire!!!</p>
            </div>

            <p class="PageText">
                And with that we have our decals! In the next and final section we will use Unity&rsquo;s Physics system to simulate the trajectory really quickly so that we
                can simply add complex trajectories to our trajectory prediction. Along with that we will setup the decals to be drawn at every collision point.
            </p>

            <p class="PageText">
                Ass always you can grab the the files up to this point
                <a href="https://github.com/FeralPug/TrajectoryPredictions/tree/main/Part4:%20Decals" title="Link to github" target="_blank">here</a>
            </p>

            <h2 class="Section" id="Part5">Part 5: Physics Simulations</h2>

            <p class="PageText">
                To handle complex trajectories we will use the physics engine in Unity to find the points along our trajectory. Unity allows us to create a copy of the physics
                scene used to simulate physics in a game. We can use this to get a copy of a physics scene that is a replica of our current scene. Then we can apply the force
                to our projectile and step through the physics in our replica scene, recording where our projectile goes along the way. The only caveat with this is that
                it isn&rsquo;t cheap.
            </p>

            <p class="PageText">
                Physics in a game can be a very resource heavy process. And trying to simulate a whole bunch of it in a single frame is not going to help frame rate. It would
                be nice if we could multi-thread the simulation or at least move it off of the main thread but sadly we cannot, physics calls have to come from the main thread.
                If you want buttery smooth 60 fps and complex trajectory prediction, you really need a top tier machine, or start writing your own physics.
            </p>

            <p class="PageText">
                With that being said though, it is a cool feature Unity exposes to us and with some coroutines we can simulate the physics over time to keep our frame rate up.
                To start we will simply get the basic simulation running, then we will run it as a coroutine, yielding after some amount of time to let the main thread continue,
                and then we will combine it with our particle system and trajectory calculations.
            </p>

            <p class="PageText">
                We first will go into our <code>TrajectoryDrawer</code> and add a struct that will hold all of the data used for the simulation. Then in <code>Awake</code>
                We are going to create a new scene passing in a <code>CreateSceneParameter</code> struct. This will prevent the new scene from auto updating the physics, which
                is what allows us to control the physics of this new system. Then we grab all the physics objects in the main scene and duplicate them passing them over to the
                new scene. We just have to make sure we make everything invisible so we are not seeing double. Make the highlighted changes.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
<span class="addition">using UnityEngine.SceneManagement;</span>

[RequireComponent(typeof(LineRenderer), typeof(LaunchController))]
public class TrajectoryDrawer : MonoBehaviour
{
    public ParticleSystemController particleSystemController;

    public TrajectoryDrawingSettings drawSettings;

    public SimulationSettings simulationSettings;

    [System.Serializable]
    public struct TrajectoryDrawingSettings
    {
        public int resolution;
        public float floor;
        public LayerMask collisionMask;
        <span class="addition">public bool simulate;</span>
    }

    <span class="addition">[System.Serializable]
    public struct SimulationSettings
    {
        public float simulationTime;
    }

    struct SimulationData
    {
        public Scene simulatedScene;
        public PhysicsScene physicsScene;
        public ProjectileController simulatedProjectile;
        public GameObject[] colliders;
    }

    SimulationData simulationData;</span>

...
</code>
</pre>
                <p class="PageImageText">
                    Adding the structs that will control our simulation. Make sure to add the using directive at the top to allow us to use the <code>SceneManagment</code> API.
                </p>
            </div>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">private void Awake()
{
    lineRenderer = GetComponent&#60LineRenderer&#62();
    launchController = GetComponent&#60LaunchController&#62();


    <span class="addition">if (drawSettings.simulate)
    {
        SetupSimulationData();
    }</span>
}

void SetupSimulationData()
{
    simulationData = new SimulationData();

    CreateSceneParameters createSceneParameters = new CreateSceneParameters(LocalPhysicsMode.Physics3D);
    simulationData.simulatedScene = SceneManager.CreateScene("Simulation Scene", createSceneParameters);
    simulationData.physicsScene = simulationData.simulatedScene.GetPhysicsScene();
    GetColliders();
    SetupSimulationScene();
}

void GetColliders()
{
    Collider[] colliders = FindObjectsOfType&#60Collider>();
    List&#60GameObject&#62 colliderRoots = new List&#60GameObject&#62();

    for(int i = 0; i < colliders.Length; i++)
    {
        GameObject go = colliders[i].transform.root.gameObject;
        if (!colliderRoots.Contains(go) && go.layer != LayerMask.NameToLayer("Player"))
        {
            colliderRoots.Add(go);
        }
    }

    simulationData.colliders = new GameObject[colliderRoots.Count];

    for (int i = 0; i < simulationData.colliders.Length; i++)
    {
        simulationData.colliders[i] = Instantiate(colliderRoots[i]);
        simulationData.colliders[i].layer = LayerMask.NameToLayer("Invisible");
    }

    simulationData.simulatedProjectile = Instantiate(launchController.projectilePrefab);
    simulationData.simulatedProjectile.gameObject.layer = LayerMask.NameToLayer("Invisible");
}

void SetupSimulationScene()
{
    SceneManager.MoveGameObjectToScene(simulationData.simulatedProjectile.gameObject, simulationData.simulatedScene);

    foreach (GameObject go in simulationData.colliders)
    {
        SceneManager.MoveGameObjectToScene(go, simulationData.simulatedScene);
    }
}
</code>
</pre>
                <p class="PageImageText">
                    Make the highlighted change to awake to only set up the simulation when needed and then add the other methods
                </p>
            </div>

            <p class="PageText">
                You may have noticed that the way I make the objects invisible is by putting them in an <code>Invisible</code> layer. This means we have to add the Invisible
                layer to our project, told you I would get back to that. Then change our camera to not see the Invisible layer by unchecking it in the <code>CullingMask</code>
                property. Also, set the Invisible layer to only interact with its self in the physics settings. We do not want things running into invisible objects in
                the main scene. I also do not add the player because it should not collide with our projectile anyway. Also, you could tag objects that you want in the simulation,
                and grab objects with tags, but this is less work up front and it is happening in <code>Awake</code> anyway, so it will not hurt our performance when it matters.
            </p>

            <p class="PageText">
                Now to get this actually working. If we are using our simulation we will call a new <code>SimulateTrajectory</code> method instead of our
                <code>CalculateTrajectoryPath</code> method. It will work by first reseting our projectile and our lineRenderer. We set the launch velocity on the projectile.
                Then we calculate how much time needs to pass before we record a point. We enter into a loop that will terminate when we have completed our simulation.
            </p>

            <p class="PageText">
                The magic happens with the <code>Simulate</code> method. We pass in the amount of time to simulate and then the physics system updates that amount of time,
                which will move our projectile. All we have to do is record its position when necessary. You may think we can increase the time step to increase the performance,
                which is true up to a point. Too high of values will cause erratic behavior, so you can adjust it but be careful. The default is 0.02f BTW. I also add a check
                just to make sure we don&rsquo;t go outside of the bounds of our array.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">private void Update()
{
    if (isDirty)
    {
        isDirty = false;

        <span class="addition">if (drawSettings.simulate)
        {
            SimulateTrajectory();
        }
        else
        {</span>
            CalculateTrajectoryPath();
        <span class="addition">}</span>
    }
}

...

void SimulateTrajectory()
{
    lineRenderer.positionCount = 0;

    //reset projectile and fire simulated projectile
    Rigidbody simBody = simulationData.simulatedProjectile.Rigidbody;
    simBody.position = launchController.transform.position;
    simBody.rotation = Quaternion.identity;
    simBody.angularVelocity = Vector3.zero;
    simBody.velocity = TrajectoryCalculator.GetLaunchDirection(launchController.transform) * launchController.launchVelocity;

    float timeStepToPoint = simulationSettings.simulationTime / drawSettings.resolution;
    points = new Vector3[drawSettings.resolution];
    int currentIndex = 0;

    for (float t = 0f; t < simulationSettings.simulationTime; t += Time.fixedDeltaTime)
    {
        if (currentIndex >= points.Length || isDirty)
        {
            break;
        }

        if (t >= timeStepToPoint * currentIndex)
        {
            lineRenderer.positionCount += 1;
            lineRenderer.SetPosition(currentIndex, simBody.position);

            points[currentIndex] = simBody.position;
            currentIndex++;
        }

        simulationData.physicsScene.Simulate(Time.fixedDeltaTime);
    }
}
</code>
</pre>
            </div>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/FirstComplexTrajectory.gif" alt="Gif of physics simulation" />
                <p class="PageImageText"> Our simulation in action</p>
            </div>

            <p class="PageText">
                Now to get this running as a coroutine we just need to set an amount of time that the simulation is allowed to run before taking a break. We call the method,
                with the <code>StartCoroutine</code> method and make sure to stop any currently running coroutines before we start a new one. Make the following changes.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">
[System.Serializable]
public struct SimulationSettings
{
    public float simulationTime;
    <span class="addition">[Range(0.0f, 0.1f)]
    public float simulationSpeed;</span>
}

...

private void Update()
{
    if (isDirty)
    {
        isDirty = false;

        if (drawSettings.simulate)
        {
            <span class="addition">StopAllCoroutines();
            StartCoroutine(</span>SimulateTrajectory()<span class="addition">)</span>;
        }
        else
        {
            CalculateTrajectoryPath();
        }
    }
}

...

<span class="addition">IEnumerator</span> SimulateTrajectory()
{
    lineRenderer.positionCount = 0;

    //reset projectile and fire simulated projectile
    Rigidbody simBody = simulationData.simulatedProjectile.Rigidbody;
    simBody.position = launchController.transform.position;
    simBody.rotation = Quaternion.identity;
    simBody.angularVelocity = Vector3.zero;
    simBody.velocity = TrajectoryCalculator.GetLaunchDirection(launchController.transform) * launchController.launchVelocity;

    float timeStepToPoint = simulationSettings.simulationTime / drawSettings.resolution;
    points = new Vector3[drawSettings.resolution];
    int currentIndex = 0;

    <span class=" addition">float startTime = Time.realtimeSinceStartup;</span>

    for (float t = 0f; t < simulationSettings.simulationTime; t += Time.fixedDeltaTime)
    {
        if (currentIndex >= points.Length || isDirty)
        {
            break;
        }

        if (t >= timeStepToPoint * currentIndex)
        {
            lineRenderer.positionCount += 1;
            lineRenderer.SetPosition(currentIndex, simBody.position);

            points[currentIndex] = simBody.position;
            currentIndex++;
        }

        simulationData.physicsScene.Simulate(Time.fixedDeltaTime);

        <span class="addition">if (Time.realtimeSinceStartup - startTime >= simulationSettings.simulationSpeed)
        {
            yield return null;

            startTime = Time.realtimeSinceStartup;
        }</span>
    }
}
</code>
</pre>

                <p class="PageImageText">
                    Those changes should save your frame rate. I set my simulationSpeed to 0.005f
                </p>
            </div>

            <p class="PageText">
                Now all that is left to do is to hook this up with our particle system and we are good to go. Because of how we set up the code for our particle system all
                we have to do is reset the particle system and call <code>SetParticle</code> for every place we detect a collision and then
                we call <code>DisplayParticles</code> to draw the particles to our scene. To find our particle&rsquo;s position we will use a RayCast just like before,
                except that we will always record the last position of the projectile as we go through our simulation, so that we can get a direction for our RayCast.
            </p>

            <div class="CodeHighlight">
<pre>
<code class="language-csharp">IEnumerator SimulateTrajectory()
{
    lineRenderer.positionCount = 0;
    <span class="addition">particleSystemController.ClearParticles();
    particleSystemController.DisplayParticles();</span>

    //reset projectile and fire simulated projectile
    Rigidbody simBody = simulationData.simulatedProjectile.Rigidbody;
    simBody.position = launchController.transform.position;
    simBody.rotation = Quaternion.identity;
    simBody.angularVelocity = Vector3.zero;
    simBody.velocity = TrajectoryCalculator.GetLaunchDirection(launchController.transform) * launchController.launchVelocity;

    float timeStepToPoint = simulationSettings.simulationTime / drawSettings.resolution;
    points = new Vector3[drawSettings.resolution];
    int currentIndex = 0;

    float startTime = Time.realtimeSinceStartup;

    <span class="addition">Vector3 lastPos = simBody.position;</span>

    for (float t = 0f; t < simulationSettings.simulationTime; t += Time.fixedDeltaTime)
    {
        if (currentIndex >= points.Length || isDirty)
        {
            break;
        }

        if (t >= timeStepToPoint * currentIndex)
        {
            lineRenderer.positionCount += 1;
            lineRenderer.SetPosition(currentIndex, simBody.position);

            points[currentIndex] = simBody.position;
            currentIndex++;
        }

        simulationData.physicsScene.Simulate(Time.fixedDeltaTime);
           
        <span class="addition">Vector3 dir = (simBody.position - lastPos).normalized;
        if(Physics.Raycast(simBody.position, dir, out RaycastHit hit, 1f, drawSettings.collisionMask))
        {
            particleSystemController.SetParticle(hit);  
            particleSystemController.DisplayParticles();
        }</span>

        lastPos = simBody.position;

        if (Time.realtimeSinceStartup - startTime >= simulationSettings.simulationSpeed)
        {
            yield return null;

            startTime = Time.realtimeSinceStartup;
        }
    }
}</code>
</pre>
                <p class="PageImageText">
                    Make the above highlighted changes to our <code>SimulateTrajectory</code> method
                </p>
            </div>

            <div class="PageImageContainer">
                <img class="PageImage" src="Media/ComplexWithTargets.gif" alt="Gif of the final Result" />
                <p class="PageImageText">
                    And with that we can show multiple decals for our trajectory. I added a bouncy physics material to
                    our projectile
                </p>
            </div>

            <p class="PageText">
                You can grab the final code 
                <a href="https://github.com/FeralPug/TrajectoryPredictions/tree/main/Part5:%20Physics%20Sim" title="Link to Github" target="_blank">here</a>.
            </p>

            <!-- these are here just so I can grab the right formatting as we write

                                <h2 class="Section" id="Part5">Part 5: Clouds</h2>

                                <div class="PageImageContainer">
                                    <img class="PageImage" src="Media/ExtendingSkyboxCapture.png" alt="Image of the final Result" />
                                    <p class="PageImageText"> An example of what you can do with procedural skyboxes</p>
                                </div>

                                <div class="PageImageContainer">
                                <div class="ImageSideBySideContainer">
                                    <img class="PageSideBySide" src="Media/StarBending0.png" alt="Picture of our projected texture" />
                                    <img class="PageSideBySide" src="Media/StarBending1.png" alt="Picture of our projected texture" />
                                </div>
                                <p class="PageImageText">
                                    On the left _StarsBending is set to 0 and on the right _StarsBending is set to 1
                                </p>
                                </div>

                                <p class="PageText">
                                </p>

                <div class="CodeHighlight">
                <pre>
                <code class="language-hlsl"></code>
                </pre>
                </div>

                <div class="CodeHighlight">
    <pre>
    <code class="language-csharp"></code>
    </pre>
                </div>


                                        https://www.freeformatter.com/html-escape.html#ad-output
                https://prismjs.com/index.html
                        <div class="CodeHighlight">
            <pre>
            <code class="language-hlsl line-numbers">
                Code Here
                            <span class="addition">Addition</span>
                            <span class="deletion"><span class="addition">Deleation</span></span>
            }</code>
            </pre>
                            <p class="PageImageText">
                                Figure Legend
                            </p>
                        </div>
                        -->

            <h2 class="Section" id="Part6">Part 6: Wrap up</h2>

            <p class="PageText">
                Now I probably wouldn&rsquo;t use this simulation in a real game given the performance constraints on it. You would be better of handling collision yourself and
                calculating trajectorys as we did in the first part. But if you were to use the simulation approach you could increase the accuracy of the target placement by
                using <code>SphereCasts</code> instead of Raycasts. In any case it is fun to get the correct trajectories this way, and the ideas used for the particle system
                could be used for all sorts of effects.
            </p>

            <p class="PageText">
                If you have any comments or something did not work for you, contact me via my
                <a href="https://feralpug.github.io/OtherPages/Support/Support.html" title="link to support page" target="_blank">support page</a>
                or DM me on twitter <a href="https://twitter.com/Feral_Pug" title="Link to my twitter page" target="_blank">@Feral_Pug</a>
                and I should respond to you soon. If you want to support me you can donate at
                <a href="https://ko-fi.com/feral_pug" title="Link to my Ko-fi page" target="_blank">ko-fi.com/feral_pug</a>.
            </p>
        </article>

        <div class="AsideContainer">
            <aside>
                <h2>Table of Contents</h2>
                <ul>
                    <li>
                        <a href="#PostStart" title="Jump to start of post">
                            Start
                        </a>
                    </li>
                    <li>
                        <a href="#Part1" title="Jump to part one">
                            Part 1: Setup
                        </a>
                    </li>
                    <li>
                        <a href="#Part2" title="Jump to part two">
                            Part 2: Trajectory Math
                        </a>
                    </li>
                    <li>
                        <a href="#Part3" title="Jump to part three">
                            Part 3: Writing Code
                        </a>
                    </li>
                    <li>
                        <a href="#Part4" title="Jump to part four">
                            Part 4: Adding Decals
                        </a>
                    </li>
                    <li>
                        <a href="#Part5" title="Jump to part five">
                            Part 5: Physics Simulation
                        </a>
                    </li>
                    <li>
                        <a href="#Part6" title="Jump to part six">
                            Part 6: Wrap up
                        </a>
                    </li>
                </ul>
            </aside>
        </div>

    </main>

    <footer>
        <p>
            All resources found here are to be used freely for any projects, commercial, personal, or otherwise.
        </p>
    </footer>
</body>
</html>
